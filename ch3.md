[代目录](ReadMe.md#代目录)

本章内容
- 讨论如何构建一个词法分析器
- 建立每个词法单元的此法结构图或其它描述
- 编写代码识别输入中出现的每个词素，返回识别到的词法单元的有关信息

自动生成词法分析器
- 向一个 __词法分析器生成工具__（lexical-analyzer generator）描述词素的模式，将这些模式编译为具有词法分析器功能的代码
- 使得修改词法分析器的工作变得更加简单，因为只需要修改受到影响的模式，无需修改整个程序
- 加快词法分析器的实现速度，程序员只需要在很高的模式层次上描述软件，就可以依赖生成工具生成详细代码
- 我们将在 [3.5 节](ch3.md#词法分析器生成工具-lex)介绍一个名为 Lex 的词法分析器生成工具（它的一个最新变体称为 Flex）

在介绍词法分析器生成工具之前，我们先介绍正则表达式
- 正则表达式是一种可以很方便地描述词素模式的方法
- 将介绍如何对正则表达式进行转换
  - 首先转换为 __不确定有穷自动机__，然后再转换为 __确定有穷自动机__
  - 后两种表示方法可以作为一个“驱动程序”的输入
  - 这个驱动程序就是一段模拟这些自动机的代码
  - 它使用这些自动机确定下一个词法单元
  - 这个驱动程序以及对自动机的规约形成了词法分析器的核心部分

# 词法分析器的作用
<i style="color:gray">对应扫描中文版pdf页码68</i>

词法分析器
- 是编译的第一个阶段
- 它的主要任务是读入源程序的输入字符、将它们组成词素，生成并输出一个词法单元序列
  - 每个词法单元对应于一个词素
  - 这个词法单元序列被输出到语法分析器进行语法分析

语法分析器通常还要和符号表进行交互
- 当 __词法分析器__ 发现了一个标识符的词素时，它要将这个词素添加到符号表中
- 某些情况下，__词法分析器__ 会从符号表中读取有关标识符种类的信息，以确定向 __语法分析__ 器传送哪个词法单元
- 这种交互关系由图给出（*略*）
  - 通常交互是由 __语法分析器__ 调用 __词法分析器__ 实现的
  - 命令 `getNextToken` 所指的调用使得 __词法分析器__ 从它的输入中不断读取字符，直到它识别出下一个词素位置
  - __词法分析器__ 根据这个词素生成下一个词法单元并返回给 __语法分析器__

词法分析器的其它任务
- 过滤掉源程序中的注释和空白（空格、换行符、制表符、输入中用于分隔词法单元的其它字符）
- 将编译器生成的错误消息与源程序的位置联系起来
  - 例如，词法分析器可以负责记录遇到的换行符个数，以便给每个出错消息赋予一个行号
  - 某些编译器中，词法分析器会建立源程序的一个拷贝，并将出错消息插入到适当位置
  - 如果源程序使用了一个宏预处理器，则宏的扩展也可以有由词法分析器完成

有时，词法分析器可以分成两个级联的处理阶段
1. __扫描阶段__：主要负责不需要生成词法单元的简单处理，如删除注释和将多个连续空白字符压缩成一个字符
2. __词法分析阶段__：是较为复杂的部分，处理扫描阶段的输出并生成词法单元

## 词法分析器及语法分析
把编译过程的分析部分划分为 __词法分析__ 和 __语法分析__ 阶段有几个原因
1. 最重要的考虑是简化编译器设计
    - 通常使我们至少可以简化其中的一项任务
    - 例如，如果一个语法分析器必须把空白符和注释当作语法单元处理，那么它会比假设空白和注释符已经被词法分析器过滤掉的处理器复杂得多
    - 分开考虑有助于得到更加清晰的语言设计方案
2. 提高编译器效率
    - 使我们能够使用专用于词法分析任务、不进行语法分析的技术
    - 可以使用专门的用于读取输入字符的缓冲技术，显著提高编译器的速度
3. 增强编译器的可移植性
    - 输入设备相关的特殊性可以被限制在词法分析器中

## 词法单元、模式和词素
三个相关但区别的术语
1. __词法单元__
   - 由一个词法单元名和一个可选的属性组成
   - 词法单元名是一个表示某种词法单位的抽象符号，比如
     - 特定的关键字
     - 代表标识符的输入字符序列
   - 词法单元名字是由 __语法分析器__ 处理的输入符号
2. __模式__
   - 描述了一个词法单元的词素可能具有的形式
   - 当词法单元是一个关键字时，它的模式就是组成这个关键字的字符序列
   - 对于标识符和其它词法单元，模式是一个更加复杂的结构，可以和很多符号串 __匹配__\
     *（haskell的parsec库中的parser是不是用来识别“模式”的呢？）*
3. __词素__
   - 源程序的一个字符序列
   - 和某个词法单元的模式匹配，并被词法分析器识别为该词法单元的一个实例

例子：给出了常见的词法单元、非正式描述的词法单元的模式，一些示例词素
| 词法单元 | 非正式描述 | 词素示例 |
|---|---|---|
|**if**|字符 i, f|if|
|**else**|字符 e, l, s, e|else|
|**comparison**|< 或 > 或 >= 或 == 或 !=|<=, !=|
|**id**|字母开头的字母/数字串|pi, score, D2|
|**number**|任何数字常量|3.14149, 0, 6, 02e23|
|**literal**|在两个 `"` 之间，除 `"` 以外的任何字符|"core dumped"|

很多程序设计语言中，下面的类别覆盖了大部分或所有词法单元
1. 每个关键字有一个词法单元。一个关键字的模式就是该关键字本身
2. 表示运算符的词法单元。它可以表示单个运算符，也可以像例子里面的 **comparison** 那样，表示一类运算符
3. 一个表示所有标识符的词法单元
4. 一个或多个表示常量的词法单元，比如数字和字面值字符串
5. 每个标点符号有一个词法单元，比如左右括号、逗号和分号

*（上面的词法单元的模式似乎都只涉及到在文本中连续的字符序列，可能在这里，haskell里面的parsec库与普通的方式之间存在区别）*

## 词法单元的属性
如果多个词素可以和一个模式匹配，那么词法分析器必须向后续阶段提供被匹配词素的附加信息
- 如，0 和 1 都能和词法单元 **number** 的模式匹配
- 词法单元的名字将影响语法分析过程的决定，而属性则会影响语法分析之后对词法单元的翻译

最重要的例子是词法单元 **id**
- 一般来说，和一个标识符有关的信息——词素、类型、第一次出现的位置——都保存在符号表中
- 一个标识符的属性值是一个指向符号表中该标识符对应条目的指针

<div style="border:1px solid;  padding:10px">

**识别词法单元时的棘手问题**
- 如果给定一个描述了某词法单元的词素的模式
- 与之匹配的词素出现在输入时，识别出匹配的词素是相对简单的
- 然而，某些程序设计语言中，要判断是否识别到一个和某词法单元匹配的词素，并不是件轻而易举的事情

例子：来自 Fortran 语言的固定格式（fixed-format）程序
``` Fortran
DO 5 I = 1.25
```
- 1 后的小数点之前，并不能确定 `DO5I` 是第一个词素，即一个标识符语法单元的实例
- 注意：Fortran 语言的固定格式中，空格是被忽略的
- 如果我们看到的是逗号，而不是小数点，我们就得到了 do 语句
  ``` Fortran
  DO 5 I = 1,25
  ```
  这个语句中，第一个词素是关键字 `DO`

</div>

例子：Fortran 语句
``` Fortran
E = M * C ** 2
```
- 其中的词法单元名字和相关属性值可以写成名字-属性对序列
  ```
  <id, 指向符号表中 E 的条目的指针>
  <assign, op>
  <id, 指向符号表中 M 的条目的指针>
  <mul, op>
  <id, 指向符号表中 C 的条目的指针>
  <exp, op>
  <number, 整数值2>
  ```

注意
- 在某些对中，特别是运算符、标点符号和关键字的对中，不需要有属性值
- 这个例子中，词法单元 numbder 有一个整数属性值
- 实践中，编译器将保存一个代表该常量的字符串，并将该字符串的指针作为 number 的属性值

## 词法错误
例子
``` C
fi (a == f(x)) ...
```
- 第一次遇到 fi 时，无法指出 fi 究竟是关键字 if 的误写还是未声明的函数标识符
- 由于 fi 是标识符 **id** 的合法词素，因此词法分析器必须向语法分析器返回 **id** 词法单元
- 让编译器的另一个阶段（这个例子中是语法分析器）处理这个因为字母颠倒而引起的错误

__恐慌模式__
- 假设出现所有词法单元模式都无法和剩余输入的某个前缀相匹配的情况，词法分析器就不能继续处理输入
- 最简单的恢复策略：__恐慌模式__ 恢复
- 从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的词法单元为止
- 可能会给语法分析器带来混乱
- 但是在交互计算环境中，这个技术足够了

其它可能采取的错误恢复动作：
1. 从剩余的输入中删除一个字符
2. 向剩余的输入中插入一个遗漏的字符
3. 用一个字符替换另一个字符
4. 交换两个相邻的字符

这些变换可以试图修复错误输入时运行

*（为什么要修复错误输入呢？可能其实也没有必要？）*

## 3.1 节的练习
*略*

*（对于第2题，似乎应该把 html 标签的开头和结尾当作括号一样的东西处理（对于这本书目前的风格而言，似乎还没有出现过被“切断”的词素））*

# 输入缓冲
<i style="color:gray">对应扫描中文版pdf页码71</i>

讨论几种可以加快源程序读入速度的方法
- 我们将介绍一种双缓冲区方案，能够安全地处理向前看多个符号的问题
- 我们将考虑一种改进方法，使用 __哨兵标记__ 来节约用于检查缓冲区末端的时间

## 缓冲区对
__缓冲区对__
- 编译大型源程序时，处理大量字符需要很多时间
- 开发了一些特殊缓冲技术减少用于处理单个输入字符的时间开销
- 一种重要的机制是利用两个交替读入的缓冲区

缓冲区的构造
- 每个缓冲区的容量都是 N 个字符，通常 N 是一个磁盘块的大小，如 4096 字节
- 使用系统读取命令，一次将 N 个字符读入到缓冲区中，而非每读取一个字符就调用一次读取命令
- 如果输入文件剩余字符不足 N 个，就会有一个特殊字符（**eof**）标记源文件的结束，不同于任何可能出现在源程序中的字符

维护两个指针
1. `lexemeBegin`：指向当前词素的开始处
2. `forward`：一直向前扫描，直到发现某个模式被匹配为止。所依据的策略将在本章其余部分讨论
    - 一旦确定了下一个词素，`forward` 指针将指向该词素结尾的字符
    - 词法分析器将这个词素作为某个返回给语法分析器的词法单元的属性值记录下来\
      *（原来如此，这样其实就无需复制字符串，并且和书中前面说得一样，这里的属性是一个指针）*

将 `forward` 指针前移要求我们首先检测是否已经到达某个缓冲区的末尾
- 如果是：将 N 个新字符读到另一缓冲区中，且将 `forward` 指针指向这个新载入字符的缓冲区的头部
- 只要我们永远不需要越过实际词素向前看很远，以至于这个词素的长度加上向前看的距离大于 N，我们就永远不会在识别这个词素之前覆盖掉尚在缓冲区的词素

## 哨兵标记
如果采用上一节的方案，必须要做两次测试
- 检查是否到达缓冲区末尾
- 确定读入的字符是什么

哨兵
- 如果扩展缓冲区，使它们在末尾包含一个 __哨兵__（sentinel）字符，就可以把两个测试合二为一
- __哨兵__ 字符必须是一个不会在源程序中出现的特殊字符，例如 **eof**

前移 `forward` 指针的算法
``` C
switch (* forward++) {
  case eof:
    if (forward 在第一个缓冲区末尾){
      装载第二个缓冲区;
      forward= 第二个缓冲区开头;
    }
    else if (forward 在第二个缓冲区末尾) {
      装载第一个缓冲区;
      forward= 第一个缓冲区的开头;
    }
    else /*缓冲区内部 eof 标记输入结束*/
      终止词法分析
    break;
}
```
*（这里的 `* forward ++` 很令人迷惑，实际上它是用 `forward` 指向的字符判断分支，同时指针 `forward` 自增）*
- 大部分情况下只需要一次测试
- 只有当我们确实属于缓冲区末尾或输入末尾时，才需要进行更多的测试

# 词法单元的规约
<i style="color:gray">对应扫描中文版pdf页码73</i>

__正则表达式__
- 一种用来描述词素模式的重要表示方法
- 虽然正则表达式不能表达出所有可能的模式，但它们可以高效地描述在处理词法单元时要用到的模式类型\
  *（为什么不能表达出所有可能的模式？）*

预告
- 这一节，我们将研究 __正则表达式__ 的形式化表示方法
- 在 [3.5 节](ch3.md#词法分析器生成工具-lex) 中，将看到如何将这些表达式运用到词法分析器生成工具
- [3.7 节](ch3.md#从正则表达式到自动机) 显示了如何将正则表达式转换成能够识别所描述词法单元的 __自动机__，由此建立一个 __词法分析器__

<div style="border:1px solid;padding:10px">

**我们会不会用完缓冲区空间？**
- 大多数现代程序设计语言中，词素很短，所以数千字节大小的缓冲区足够，[3.2.1 节](ch3.md#缓冲区对) 中介绍的双缓冲方案肯定没问题
- 但是存在风险
- 例如，字符串包括很多行，可能面临单个词素长度超过 N 的情况\
  *（明白了，语言中的字符串本身整体是个词素，如果字符串很长，还是会有问题）*
- 为了避免长字符串问题，我们可以把它们看作不同部分的连接，每个组成部分对应该字符串的一行
- 比如 Java 语言中，人们习惯将一个字符串写成多个部分，每部分占一行并加上 `+`

需要向前看任意多个字符时，会出现一个更加严重的问题
- 比如 PL/I 这样的语言没有将关键字作为 __保留字__，可以使用和关键字同名的标识符
- 词法分析器有时不能确定是否是一个关键字还是一个带参数的过程名
- 因此，大多数现代程序设计语言都保留关键字
- 如果不保留关键字，我们可以把它当作一个二义性的标识符，由 __语法分析器__ 解决这个问题，此时语法分析器需要在符号表中查询信息

</div>

## 串和语言
__字母表__（alphabet）是一个优先的符号集合
- 符号的典型例子：字母、数位和标点符号
- 字母表的例子
  - __二进制字母表__（binary alphabet）：{0, 1}
  - ASCII
  - Unicode

<div style="border:1px solid;padding:10px">

**实现多路分支**
- 我们也许会认为 `switch` 需要执行很多步
- 事实上，按照什么顺序列出针对各个字符的 case 并不重要
- 实践中，可以用一个以字母为下标的地址数组存放对应于各 case 的指令地址，一次性完成跳转
</div>

__串__（string）
- 某个字母表上的 __串__ 是该字母表符号的一个有穷序列
- 语言理论中，“句子”和“字”常常被当作“串”的同义词
- 串 `s` 的长度，通常记作 `|s|`，是指 `s` 中符号出现的次数

__语言__
- 是某个给定字母表上一个任意的可数的串集合
- 这个定义非常宽泛，根据这个定义，像空集 Φ 和仅包含空串的集合 `{ε}` 都是语言
- 这个定义并没有要求语言中的串一定具有某种含义
- 定义串的“含义”的方法将在 [第5章](ch5.md) 中讨论

<div style="border:1px solid;padding:10px">

**串的各部分的术语**
1. 串 `s` 的 __前缀__（prefix）：从 `s` 的尾部删除 0 个或多个符号后得到的串
2. 串 `s` 的 __后缀__（suffix）：从 `s` 的开始处删除 0 个或多个符号后得到的串
3. 串 `s` 的z __子串__（substring）：删除 `s` 的某个前缀和某个后缀之后得到的串
4. 串 `s` 的 __真__（true）前缀、真后缀、真字串：`s` 的既不等于 ε，也不等于 s 本身的前缀、后缀和子串
5. 串 `s` 的 __子序列__（substring）：从 `s` 中删除 0 个或多个符号后得到的串，被删除的符号可能不相邻
</div>

其它术语
- __连接__
  - `x` 和 `y` 是串，`x` 和 `y` 的 __连接__（concatenation）（记作 `xy`）是把 `y` 附加到 `x` 后面形成的串
  - 空串是连接运算的单位元，对于任何串 `s`，都有 `sε = εs = s`
- 如果把串的连接看成“乘积”，那么可以定义串的“指数”
  - $s^0$ 为 ε
  - 对于 i>0，$s^i$ 为 $s^{i-1}s$
  - 因为 εs=s，因此 $s^1=s, s^2=ss, s^3=sss$，依此类推

## 语言上的运算
__语言__ 上的并、连接和闭包运算定义
| 运算 | 定义和表示 |
|-|-|
| L 和 M 的并 | $L\cup M=\{s\| s 属于 L 或者 s 属于 M\}$ |
| L 和 M 的连接 | $LM = \{st\| s 属于 L 且 t 属于 M\}$ |
| L 的 Kleene 闭包 | $L^*=\cup^\infty_{i=0} L^i$ |
| L 的正闭包 | $L^+=\cup^\infty_{i=1} L^i$ |
- __并运算__：常见的集合运算
- __连接__：以各种可能的方式，从第一个语言中任取一个串，从第二个语言中任取一个串，将它们连接后得到的所有串的集合
- __Kleene 闭包__（closure）：记为 $L^*$，将 L 连接 0 次或多次后得到的串集
  - $L^0$ 被定义为 $\{\epsilon\}$
  - $L^i$ 被归纳地定义为 $L^{i-1}L$
- L的正闭包：记为 $L^+$，和 Kleene 闭包基本相同，但是不包含 $L^0$
  - 除非 ε 属于 L，否则 ε 不属于 $L^+$

例子：
- 令 L 表示字母的集合 `{A, B, ..., Z, a, b, ..., z}`
- 令 D 表示数位的集合 `{0, 1, ..., 9}`
- 用两种不同但等价的方式考虑 L 和 D
  1. 将 L 看成大、小写字母组成的字母表，将 D 看成是 10 个数位组成的字母表
  2. 将 L 和 D 看作语言，它们的所有串的长度都为一
- 根据运算符从 L 和 D 构造得到新语言
  1. $L\cup D$ 字母和数位的集合——严格地讲，这个语言包含 62 个长度为 1 的串，每个串都是一个字母或数位
  2. $LD$ 是一个包含 520 个长度为 2 的串的集合，每个串都是一个字母跟一个数位
  3. $L^4$ 是所有由四个字母构成的串的集合
  4. $L^*$ 是所有由字母构成的串的集合，包括空串 ε
  5. $L(L\cup D)^*$ 是所有以字母开头的，由字母和数位组成的串的集合
  6. $D^+$ 是由一个或多个数位构成的串的集合

*(没错，这些例子里面有一些在语言中其实很常见)*

## 正则表达式
假设我们要描述 C 语言的所有合法标识符集合，它差不多就是刚才例子中第 5 项的语言，唯一的不同是 C 语言标识符可以包括下划线

正则表达式
- 人们常常使用一种称为 __正则表达式__ 的表示方法描述语言
- 可以描述所有通过某个字母表上的符号应用这些运算符而得到的语言

如果使用 `letter_` 来表示任一字母或下划线，用 `digit` 来表示数位，那么可以用如下的正则表达式描述对应于 C 语言标识符的语言
```
letter_(letter_|digit)*
```

正则表达式可以由较小的正则表达式按照如下规则递归地构建
- 每个正则表达式 r 表示一个语言 L(r)
- 这个语言也是根据 r 的子表达式所所表示的语言递归地定义的

下面的规则定义了某个字母表 Σ 上的正则表达式以及这些表达式所表示的语言
- __归纳基础__：如下两个规则构成归纳基础
  1. **ε** 是一个正则表达式， L(**ε**)={ε}，即该语言指包含空串
  2. 如果 a 是 Σ 上的一个符号，那么 **a** 是一个正则表达式，并且 L(**a**)={a}
      - 也就是说，这个语言包含一个长度为 1 的符号串 a
      - 根据惯例，我们通常用粗体表示符号对应的正则表达式
- __归纳步骤__：由较小的正则表达式构成较大的正则表达式；假设 **r** 和 **s** 都是正则表达式，分别表示语言 L(**r**) 和 L(**s**)，那么
  1. (r) | (s) 是一个正则表达式，表示语言 $L(r)\cup L(s)$
  2. (r) (s) 是一个正则表达式，表示语言 $L(r)L(s)$
  3. (r)* 是一个正则表达式，表示语言 $(L(r))^*$
  4. (r) 是一个正则表达式，表示语言 $L(r)$；最后的这个规则是说在表达式两边加上括号并不影响表达式所表示的语言

按照上面的定义，正则表达式经常会包含一些不必要的括号，可以采取约定丢掉一些括号
1. 一元运算符 `*` 具有最高优先级，是左结合的
2. 连接具有次高的优先级，也是左结合的
3. `|` 的优先级最低，并且也是左结合的

例如
- `(a)|(b)*(c)` 改写为 `a|b*c`

例子：*略*

__正则集合__：可以用正则表达式定义的语言
- 如果两个正则表达式 r 和 s 表示同样的语言，称 r 和 s __等价__（equivalent），记作 r=s
- 正则表达式遵守一些代数定律，每个定律都断言两个具有不同形式的表达式等价

| 定律 | 描述 |
|-|-|
| `r\|s=s\|r` | `\|` 是可以交换的 |
| `r\|(s\|t)=(r\|s)\|t` | `\|` 是可结合的 |
| `r(st)=(rs)t` | 连接是可结合的 |
| `r(s\|t)=rs\|rt;(s\|t)r=sr\|tr` | 连接对 `\|` 是可分配的 |
| `εr=rε=r` | `ε` 是连接的单位元 |
| `r*=(r\|ε)*` | 闭包中一定包含 `ε` |
| `r**=r*` | `*` 具有幂等性 |

## 正则定义
我们希望给某些正则表达式命名，在之后的正则表达式中像使用符号一样使用这些名字

Σ 是基本符号的集合，__正则定义__（regular definition）是具有如下形式的定义序列
```
d1->r1
d2->r2
...
dn->rn
```
- 每个 $d_i$ 都是一个新符号，它们都不在 Σ 中，并且各不相同
- 每个 $r_i$ 是字母表 $\Sigma\cup\{d_1,d_2,\cdots,d_{i-1}\}$ 上的正则表达式

避免递归定义：限制了每个 $r_i$ 中只含有 Σ 中的符号和在它之前定义的各个 $d_j$

例子：C 标识符对应的语言的正则定义
```
letter_ -> A|B|...|Z|a|b|...|z|
  digit -> 0|1|...|9
     id -> letter_(letter_|digit)*
```

例子：（整型或浮点型）无符号数是形如 `5280`、`0.01234`、`6.336E-4` 的串
```
           digit -> 0|1|...|9
          digits -> digit digit*
optionalFraction -> . digits | ε
optionalExponent -> (E (+|-|ε) digits) | ε
          number -> digits optionalFraction optionalExponent
```

## 正则表达式的扩展
自从 Kleene 在 20 世纪 50 年代提出带有基本运算符并、连接和 Kleene 闭包的正则表达式之后，出现了很多扩展

这里介绍一些最早出现在像 Lex 这样的 Unix 使用程序中的扩展表示法
1. __一个或多个实例__：单目后缀运算符 `+`，具有和 `*` 相同的优先级和结合性
2. __零个或一个实例__：单目后缀运算符 `?`，具有和 `*` 相同的优先级和结合性
3. __字符类__：当 `a1,a2,...,an` 形成逻辑上连续的一个序列时（连续的大写字母、小写字母或数位），可以表示成 `a1-an`

例子：
- 将标识符的正则定义改成
  ```
  letter_ -> [A-Za-z_]
    digit -> [0-9]
       id -> letter_ (letter_|digit)*
  ```
- 无符号数字的正则定义简化为
  ```
   digit -> [0-9]
  digits -> digit+
  number -> digits (. digits)? (E [+-]? digits)?
  ```

## 3.3 节的练习
*略（感觉太难了）*

|表达式|匹配|例子|
|-|-|-|
|c|单个非运算符字符c|a|
|\c|字符c的字面值|\*|
|"s"|串s的字面值|"**"|
|.|除换行意外的任何字符|a.*b|
|^|一行的开始|^abc|
|$|行的结尾|abc$|
|[s]|字符串 s 中的任何一个字符|[abc]|
|[^s]|不在字符串 s 中的任何一个字符|[^abc]|
|r*|和 r 匹配的零个或多个串连接成的串|a*|
|r+|和 r 匹配的一个或多个串连接成的串|a+|
|r?|零个或一个 r|a?|
|r{m,n}|最少 m 个，最多 n 个 r 的重复出现|a{1,5}|
|r1r2|r1 后加上 r2|ab|
|r1\|r2|r1 或 r2|a\|b|
|(r)|与 r 相同|(a\|b)|
|r1/r2|后面跟有 r2 时的 r1|abc/123|

*略*

# 词法单元的识别
<i style="color:gray">对应扫描中文版pdf页码80</i>

学习根据需要识别的词法单元的模式构造出一端代码
- 检查输入字符串
- 在输入的前缀中找到一个和某个模式匹配的词素

例子：
- 文法片段描述了分支语句和条件表达式的一种简单形式
  ```
  stmt -> if expr then stmt
        | if expr then stmt else stmt
        | ε
  expr -> term relop term
        | term
  term -> id
        | number
  ```
  - 这个语法和 Pascal 语言的语法类似
  - 对于 relop，我们使用 Pascal 或 SQL 语言中的比较运算符
- 文法的终结符号：if、then、else、relop、id 和 number 都是词法单元的名字
- 这些词法单元的模式使用正则定义描述
  ```
   digit -> [0-9]
  digits -> digit+
  number -> digits (. digits)? (E [+-]? digits)?
  letter -> [A-Za-z]
      id -> letter (letter | digit)*
      if -> if
    then -> then
    else -> else
   relop -> < | > | <= | >= | = | <>
  ```
  *（这里的 `<>` 应该是不等于的意思）*

为了简化问题，我们做出假设：
- 关键字也是也是 __保留字__，它不是标识符
- 我们还让词法分析器负责消除空白符，方法是让它识别“词法单元” ws
  ```
  ws -> (blank | tab | newline)+
  ```
  词法单元 ws 不同之处在于
  - 当我们识别到 ws 时，我们并不将它返回给语法分析器
  - 而是从这个空白之后继续进行词法分析

词法分析器的目标
| 词素 | 词法单元名字 | 属性值 |
|-|-|-|
| Any ws | - | - |
| if | if | - |
| then | then | - |
| else | else | - |
| Any id | id | 指向符号表条目的指针 |
| Any number | number | 指向符号表条目的指针 |
| < | relop | LT |
| <= | relop | LE |
| = | relop | EQ |
| <> | relop | NE |
| > | relop | GT |
| >= | relop | GE |
- 对于各个词素或词素的集合，该表显示了
  - 将哪个词法单元返回给关系运算符
  - 按照 [3.1.3 节](ch3.md#词法单元的属性) 的介绍，应该返回什么属性值
- 对于其中 6 个关系运算符，符号常量 `LT` 等被当作属性值返回，目的是指明我们发现的是词法单元 relop 的哪个实例

## 状态转换图
作为构造词法分析器的一个中间步骤，我们首先将模式转换成具有特定风格的流图：__状态转换图__

预告
- 本节，用手工方式将 __正则表达式__ 表示的模式转化为 __状态转换图__
- [3.6 节] 中，使用自动化的方法根据一组正则表达式集合构造出 __状态转换图__

__状态转换图__（transition diagram）
- 有一组被称为 __状态__（state）的结点或圆圈
  - 将一个状态看作是对已经看到的位于 `lexemeBegin` 指针和 `forward` 指针之间的字符的总结，包含了我们在词法分析时需要的全部信息
- __边__（edge）：从图的一个状态指向另一个状态
  - 每条边的 __标号__ 包含了一个或多个符号
  - 如果位于状态 s，下一个输入符号是 a，我们就会寻找一条从 s 离开，且符号为 a 的边（该边的标号中可能还包括其它符号）
  - 如果找到了这样一条边，就将 `forward` 指针前移，进入状态转换图中该边所指的状态

假设所有的状态转换图都是 __确定的__：
- 对于任何一个给定状态和任何一个给定的符号
- 最多只有一条从该状态离开的边的标号包含该符号\
  *（每次转换最多只能走一条边，要么就无边可走，如果有多条边可走，就表示不是“确定的”）*
- 从 [3.5 节](ch3.md#词法分析器生成工具-lex) 开始，我们将放松对确定性的要求，令词法分析器设计者更容易完成任务，但同时提高了技巧要求

重要约定
1. __接受状态__ 或 __最终状态__
    - 已经找到了一个词素，虽然实际的词素可能不包括 `lexemeBegin` 指针和 `forward` 指针之间的所有字符
    - 用双层的圈表示接受状态
    - 如果在接受状态要执行动作——通常是向语法分析器返回词法单元和属性值——把这个动作附加到接受状态上
2. 回退
    - 如果要将 `forward` 回退一个位置，在接受状态附近加一个 `*`
    - 我们的例子都不需要将 `forward` 回退多个位置，但万一出现这种情况，回退几个就加几个 `*`
3. __开始状态__ 或 __初始状态__
    - 一个状态被指定为 __开始状态__，也称 __初始状态__
    - 由一条没有出发结点的、标号为“start”的边指明
    - 读入任何输入符号前，状态转换图总是位于开始状态

例子：能够识别所有与词法单元 `relop` 匹配的词素的状态转换图
```
─ start ─ (0)
          ├─ < ── (1)
          │       ├─ = ────── ((2)) return (relop,LE)
          │       ├─ > ────── ((3)) return (relop,NE)
          │       └─ other ── ((4)) return (relop,LT)
          ├─ = ────────────── ((5)) return (relop, EQ)
          └─ > ── (6)
                  ├─ = ────── ((7)) return (relop,GE)
                  └─ other ── ((8)) return (relop,GT)
```
- 解释：*略*
- 注意，如果在状态 0 时我们看到的是不同于 <、= 或 > 的字符，我们就不可能看到一个 relop 的词素，因此这个状态转换图将不会被使用 

*（所谓状态转换图，转换过程中只有 `forward` 指针的位置在不断移动，期间 `lexemeBegin` 其实是不变的；到达接受状态之后，才会根据 `forward` 指针处在的位置更新 `lexemeBegin` 指针）*

## 保留字和标识符的识别
需要区分保留字和标识符，可以使用两种方式
1. 初始化时将各个保留字填入符号表中
2. 为每个关键字建立单独的状态转换图
    - 有必要检查该标识符是否结束，否则可能会错误地识别以“关键字”为前缀的标识符
    - 如果采用这个方法，我们必须设定词法单元之间的优先级，使得当一个词素同时匹配 **id** 的模式和 __关键字__ 的模式时，优先识别保留字词法单元
    - 我们 *并没有* 在例子中使用这个方法

## 完成我们的例子
*略*

## 基于状态转换图的词法分析器的体系结构
有几种方法可以根据一组状态转换图构造出一个 __词法分析器__
- 想象一个变量 `state` 保存了一个状态转换图的当前状态编号
- 有一个 switch 语句根据 `state` 的值将我们转到对应于各个可能状态的相应代码段，在那里找到需要执行的动作
- 一个状态的代码本身常常也是一条 `switch` 语句或多路分支语句，这个语句读入并检查下一个输入字符，确定下一个状态

例子：`getRelop()` 方法的一个概述
``` Cpp
TOKEN getRelop ()
{
  TOKEN retToken = new(RELOP);
  while(1) { // 重复直到返回或者失败
    switch (state) {
      case 0: 
        c = nextChar();
        if (c == '<') state = 1;
        else if (c == '=') state = 5;
        else if (c == '>') state = 6;
        else if fail (); // 词素不是 relop
        break;
      case 1: ...
      ...
      case 8:
        retract();
        retToken.attribut = GT;
        return (retToken); 
    }
  }
}
```
- 解释：*略*

为了在适当的地方模拟适当的状态转换图，考虑几种方式将代码集成到整个 __词法分析器__ 中
1. 让词法分析器顺序地尝试各个词法单元的装填转换图
2. “并行地”运行各个状态转换图
    - 将下一个输入字符提供给所有的状态转换图，使得每个状态转换图作出它应该执行的转换
    - 必须谨慎解决如下问题
      > 一个状态转换图已经找到了一个和模式匹配的词素，但另外的一个/多个状态转换图仍然可以继续处理输入
    - 常见策略：取最长的和某个模式相匹配的输入前缀；例如 **thenext** 标识符不能识别为 **then**\
3. 更好的方法：将所有的状态转换图合并为一个图
    - 允许合并后的状态转换图尽量读取输入，直到不存在下一个状态为止
    -  像上面 2 中讨论的那样取最长的词素
    - 一般而言，合并几个词法单元的状态转换图的问题会更加复杂

## 3.4 节的练习
*略，偷懒不做*

Knuth、Morris 和 Pratt 提出了一种在文本串中识别单个关键字 $b_1b_2\cdots b_n$ 的算法
- trie（字典树）：一个包含了从 0~n 共 n+1 个状态的状态转换图
- 0 是初始状态，n 表示接受（匹配成功）
- 从 0 到 n-1 之间的任何一个状态 s 出发，存在一个标号为 $b_{s+1}$ 的到达状态 s+1 的转换
- 为了快速在串中搜索关键字，针对关键字 $b_1b_2\cdots b_n$ 以及该关键字中的位置 s 定义 __失效函数__ $f(s)$
- 函数的目标是使得 $b_1b_2\cdots b_{f(s)}$ 是
  - 最长的
  - 既是 $b_1b_2\cdots b_s$ 的真前缀
  - 又是 $b_1b_2\cdots b_s$ 的真后缀的子串

作用
- 试图用文本串匹配 $b_1b_2\cdots b_n$，已经匹配了前s个位置
- 此时匹配失败
- 那么 $f(s)$ 就是可能和以我们当前位置为结尾的文本串相匹配的，最长的 $b_1b_2\cdots b_n$ 的前缀

例子：根据 `ababaa` 构造的 trie 
```
   a    b    a    b    a    a
(0)->(1)->(2)->(3)->(4)->(5)->((6))
```
的失效函数
| s | 1 | 2 | 3 | 4 | 5 | 6 |
|-|-|-|-|-|-|-|
| f(s) | 0 | 0 | 1 | 2 | 3 | 1 |

*（简单来说，想要用字符串匹配 `ababaa`，假如已经成功匹配了 `aba`，但后面出了问题，没法继续匹配；这时最好截取一个尾部，假装我们在匹配 `a`，也就是 f(3)=1）*

*（书里也说了，当 $b_1b_2\cdots b_n$ 匹配失败时，我们可以试试 $b_1b_2\cdots b_{f(s)}$；如果再不行，那么其实应该试试 $b_1b_2\cdots b_{f(f(s))}$）*

*练习题略，偷懒*

Aho 和 Corasick 对 KMP 算法进行了推广，使它可以在文本串中识别一个关键字集合中的任何关键字\
*（你可能会对“KMP 算法”感到疑惑，其实这是上面出现的三个人的名字缩写）*
- 这种情况下，trie 是一棵真正的树，从其根节点开始就出现分支
- *我已经知道字典树的概念了，这里略*
- 对应于关键字 `he`、`she`、`his`、`hers` 的 trie 树
  ```
  (0)
  ├─h── (1) ──e── ((2)) ──r── (8)  ──s── ((9))
  │     └─i── (6) ──s── ((7))
  └─s── (3) ──h── (4)  ──e── ((5))
  ```
- 通用的 trie 树失效函数定义
  - 假设 s 是对应于串 $b_1b_2\cdots b_n$ 的状态，状态 $f(s)$ 对应于
    - 最长的
    - 既是 $b_1b_2\cdots b_n$ 的后缀又是某个关键字前缀的字符串
- 例如，例子中 trie 树的失效函数
  |s|1|2|3|4|5|6|7|8|9|
  |-|-|-|-|-|-|-|-|-|-|
  |f(s)|0|0|0|1|2|0|3|0|3|

*（确实很巧妙，即使是匹配中途失败了，也能立刻找到损失不那么大的另一个选择）*

*略，继续偷懒*

# 词法分析器生成工具 Lex
<i style="color:gray">对应扫描中文版pdf页码89</i>

Lex 工具，最近的实现中也成为 Flex
- 支持使用正则表达式描述各个词法单元的模式，给出一个词法分析器的规约
- Lex 工具的输入表示方法称为 Lex 语言（Lex language）
- 工具本身称为 __Lex 编译器__（Lex compiler）
- 核心部分，Lex 编译器将输入的模式转换成一个状态转换图，生成相应的实现代码，存放到文件 `lex.yy.c` 中

如何将正则表达式翻译为状态转换图是 [下一节](ch3.md#有穷自动机) 讨论的主题，这里我们只学习 Lex 语言

## Lex 的使用
使用方法
- 用 Lex 语言写一个输入程序，描述要生成的词法分析器，输入文件称为 `lex.1`，转换成 C 语言程序，文件名总是`lex.yy.c` 
- `lex.yy.c` 总是被 C 编译器编译为一个名为 `a.out` 的文件，就是一个读取输入字符流并生成词法单元流的词法分析器
- `a.out` 通常是一个被语法分析器调用的子例程
  - 这个子例程返回一个整数值是可能出现的某个词法单元名的编码
  - 词法单元的属性值（数字编码/指向符号表的指针/什么都没有）都保存在全局变量 `yylval` 中\
    *（作者注：`yylval` 和 `lex.yy.c` 中出现的 `yy` 指的是我们将在 [4.9 节] 中讨论的语法分析器生成工具 yacc，一般和 Lex 一起使用）*
  - 这个变量由词法分析器和语法分析器共享

## Lex 程序的结构
Lex 具有如下形式
```
声明部分
%%
转换规则
%%
辅助函数
```
- 声明部分：包括
  - 变量
  -  __明示常量__（manifest constant）被声明、表示一个常数的标识符，如一个词法单元的名字
  - [3.3.4 节](ch3.md#正则定义) 中描述的正则定义
- __转换规则__ 的形式：`模式 { 动作 }`
  - 每个模式是一个正则表达式，可以使用声明部分给出的正则定义
  - 动作部分是代码片段
  - 人们已经创建了很多能使用其它语言的 Lex 变体，但这些代码片段通常是由 C 语言编写的
- 动作需要使用的 __辅助函数__
  - 还有一种方法是将这些函数单独编译，并与词法分析器的代码一起装载

Lex 创建的词法分析器和语法分析器协同工作
- 当 __词法分析器__ 被 __语法分析器__ 调用，词法分析器开始从余下的输入中逐个读取字符
- 直到发现最长的和某个模式 $P_i$ 匹配的前缀，执行动作 $A_i$
- 通常 $A_i$ 会将控制返回给 __语法分析器__
- 如果它不返回控制（识别到空白符或注释），__词法分析器__ 就继续寻找其它词素
- 直到某个动作将控制返回给 __语法分析器__

词法分析器向语法分析器的返回值
- 只返回一个值，即词法单元名
- 需要时可以利用共享的整型变量 `yylval` 传递有关这个词素的附加信息

例子：
``` lex
%{
  /* 定义明示常量
  LT, LE, EQ, NE, GT, GE,
  IF, THEN, ELSE, ID, NUMBER, RELOP */
}

/* 正则定义 */
delim     [ \t\n]
ws        {delim}+
letter    [A-Za-z]
digit     [0-9]
id        {letter}({letter}|{digit})*
number    {digit}+(\.{digit}+)?(E[+-]?{digit}+)?

%%

{ws}      {/* 无动作,无返回 */}
if        {return(IF);}
then      {return(THEN);}
else      {return(ELSE);}
{id}      {yylval = (int) installID(); return(ID);}
{number}  {yylval = (int) installNum(); return(NUMBER);}
"<"       {yylval = LT; return(RELOP)}
"<="      {yylval = LE; return(RELOP)}
"="       {yylval = EQ; return(RELOP)}
"<>"      {yylval = NE; return(RELOP)}
">"       {yylval = GT; return(RELOP)}
">="      {yylval = GE; return(RELOP)}

%%

int installID() {
  /* 用来安装词素的函数，
  它的第一个字符用 yytext 
  作为指针，它的长度是 yyleng，
  放入符号表，返回一个指针*/
}

int installNum() {
  /* 类似于 installID，
  但是把数字常量放进一个
  分离的表格*/
}

```
解释：*略*

## Lex 中的冲突解决
前面已经间接提到了 Lex 解决冲突的两个规则，当输入的多个前缀与一个或多个模式匹配时：
1. 总是选择最长的前缀
2. 如果最长的可能前缀和多个模式匹配，总是选择在 Lex 程序中先被列出的模式

例子：*略*

## 向前看运算符

## 3.5 节的练习

# 有穷自动机
<i style="color:gray">对应扫描中文版pdf页码93</i>

# 从正则表达式到自动机
<i style="color:gray">对应扫描中文版pdf页码96</i>

# 词法分析器生成工具的设计
<i style="color:gray">对应扫描中文版pdf页码105</i>

# 基于 DFA 的模式匹配器的优化
<i style="color:gray">对应扫描中文版pdf页码109</i>

# 第 3 章总结
<i style="color:gray">对应扫描中文版pdf页码118</i>

[代目录](ReadMe.md#代目录)