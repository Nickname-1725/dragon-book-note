[代目录](ReadMe.md#代目录)

本章内容
- 讨论如何构建一个词法分析器
- 建立每个词法单元的此法结构图或其它描述
- 编写代码识别输入中出现的每个词素，返回识别到的词法单元的有关信息

自动生成词法分析器
- 向一个 __词法分析器生成工具__（lexical-analyzer generator）描述词素的模式，将这些模式编译为具有词法分析器功能的代码
- 使得修改词法分析器的工作变得更加简单，因为只需要修改受到影响的模式，无需修改整个程序
- 加快词法分析器的实现速度，程序员只需要在很高的模式层次上描述软件，就可以依赖生成工具生成详细代码
- 我们将在 [3.5 节](ch3.md#词法分析器生成工具-lex)介绍一个名为 Lex 的词法分析器生成工具（它的一个最新变体称为 Flex）

在介绍词法分析器生成工具之前，我们先介绍正则表达式
- 正则表达式是一种可以很方便地描述词素模式的方法
- 将介绍如何对正则表达式进行转换
  - 首先转换为 __不确定有穷自动机__，然后再转换为 __确定有穷自动机__
  - 后两种表示方法可以作为一个“驱动程序”的输入
  - 这个驱动程序就是一段模拟这些自动机的代码
  - 它使用这些自动机确定下一个词法单元
  - 这个驱动程序以及对自动机的规约形成了词法分析器的核心部分

# 词法分析器的作用
<i style="color:gray">对应扫描中文版pdf页码68</i>

词法分析器
- 是编译的第一个阶段
- 它的主要任务是读入源程序的输入字符、将它们组成词素，生成并输出一个词法单元序列
  - 每个词法单元对应于一个词素
  - 这个词法单元序列被输出到语法分析器进行语法分析

语法分析器通常还要和符号表进行交互
- 当 __词法分析器__ 发现了一个标识符的词素时，它要将这个词素添加到符号表中
- 某些情况下，__词法分析器__ 会从符号表中读取有关标识符种类的信息，以确定向 __语法分析__ 器传送哪个词法单元
- 这种交互关系由图给出（*略*）
  - 通常交互是由 __语法分析器__ 调用 __词法分析器__ 实现的
  - 命令 `getNextToken` 所指的调用使得 __词法分析器__ 从它的输入中不断读取字符，直到它识别出下一个词素位置
  - __词法分析器__ 根据这个词素生成下一个词法单元并返回给 __语法分析器__

词法分析器的其它任务
- 过滤掉源程序中的注释和空白（空格、换行符、制表符、输入中用于分隔词法单元的其它字符）
- 将编译器生成的错误消息与源程序的位置联系起来
  - 例如，词法分析器可以负责记录遇到的换行符个数，以便给每个出错消息赋予一个行号
  - 某些编译器中，词法分析器会建立源程序的一个拷贝，并将出错消息插入到适当位置
  - 如果源程序使用了一个宏预处理器，则宏的扩展也可以有由词法分析器完成

有时，词法分析器可以分成两个级联的处理阶段
1. __扫描阶段__：主要负责不需要生成词法单元的简单处理，如删除注释和将多个连续空白字符压缩成一个字符
2. __词法分析阶段__：是较为复杂的部分，处理扫描阶段的输出并生成词法单元

## 词法分析器及语法分析
把编译过程的分析部分划分为 __词法分析__ 和 __语法分析__ 阶段有几个原因
1. 最重要的考虑是简化编译器设计
    - 通常使我们至少可以简化其中的一项任务
    - 例如，如果一个语法分析器必须把空白符和注释当作语法单元处理，那么它会比假设空白和注释符已经被词法分析器过滤掉的处理器复杂得多
    - 分开考虑有助于得到更加清晰的语言设计方案
2. 提高编译器效率
    - 使我们能够使用专用于词法分析任务、不进行语法分析的技术
    - 可以使用专门的用于读取输入字符的缓冲技术，显著提高编译器的速度
3. 增强编译器的可移植性
    - 输入设备相关的特殊性可以被限制在词法分析器中

## 词法单元、模式和词素
三个相关但区别的术语
1. __词法单元__
   - 由一个词法单元名和一个可选的属性组成
   - 词法单元名是一个表示某种词法单位的抽象符号，比如
     - 特定的关键字
     - 代表标识符的输入字符序列
   - 词法单元名字是由 __语法分析器__ 处理的输入符号
2. __模式__
   - 描述了一个词法单元的词素可能具有的形式
   - 当词法单元是一个关键字时，它的模式就是组成这个关键字的字符序列
   - 对于标识符和其它词法单元，模式是一个更加复杂的结构，可以和很多符号串 __匹配__\
     *（haskell的parsec库中的parser是不是用来识别“模式”的呢？）*
3. __词素__
   - 源程序的一个字符序列
   - 和某个词法单元的模式匹配，并被词法分析器识别为该词法单元的一个实例

例子：给出了常见的词法单元、非正式描述的词法单元的模式，一些示例词素
| 词法单元 | 非正式描述 | 词素示例 |
|---|---|---|
|**if**|字符 i, f|if|
|**else**|字符 e, l, s, e|else|
|**comparison**|< 或 > 或 >= 或 == 或 !=|<=, !=|
|**id**|字母开头的字母/数字串|pi, score, D2|
|**number**|任何数字常量|3.14149, 0, 6, 02e23|
|**literal**|在两个 `"` 之间，除 `"` 以外的任何字符|"core dumped"|

很多程序设计语言中，下面的类别覆盖了大部分或所有词法单元
1. 每个关键字有一个词法单元。一个关键字的模式就是该关键字本身
2. 表示运算符的词法单元。它可以表示单个运算符，也可以像例子里面的 **comparison** 那样，表示一类运算符
3. 一个表示所有标识符的词法单元
4. 一个或多个表示常量的词法单元，比如数字和字面值字符串
5. 每个标点符号有一个词法单元，比如左右括号、逗号和分号

*（上面的词法单元的模式似乎都只涉及到在文本中连续的字符序列，可能在这里，haskell里面的parsec库与普通的方式之间存在区别）*

## 词法单元的属性
如果多个词素可以和一个模式匹配，那么词法分析器必须向后续阶段提供被匹配词素的附加信息
- 如，0 和 1 都能和词法单元 **number** 的模式匹配
- 词法单元的名字将影响语法分析过程的决定，而属性则会影响语法分析之后对词法单元的翻译

最重要的例子是词法单元 **id**
- 一般来说，和一个标识符有关的信息——词素、类型、第一次出现的位置——都保存在符号表中
- 一个标识符的属性值是一个指向符号表中该标识符对应条目的指针

<div style="border:1px solid;  padding:10px">

**识别词法单元时的棘手问题**
- 如果给定一个描述了某词法单元的词素的模式
- 与之匹配的词素出现在输入时，识别出匹配的词素是相对简单的
- 然而，某些程序设计语言中，要判断是否识别到一个和某词法单元匹配的词素，并不是件轻而易举的事情

例子：来自 Fortran 语言的固定格式（fixed-format）程序
``` Fortran
DO 5 I = 1.25
```
- 1 后的小数点之前，并不能确定 `DO5I` 是第一个词素，即一个标识符语法单元的实例
- 注意：Fortran 语言的固定格式中，空格是被忽略的
- 如果我们看到的是逗号，而不是小数点，我们就得到了 do 语句
  ``` Fortran
  DO 5 I = 1,25
  ```
  这个语句中，第一个词素是关键字 `DO`

</div>

例子：Fortran 语句
``` Fortran
E = M * C ** 2
```
- 其中的词法单元名字和相关属性值可以写成名字-属性对序列
  ```
  <id, 指向符号表中 E 的条目的指针>
  <assign, op>
  <id, 指向符号表中 M 的条目的指针>
  <mul, op>
  <id, 指向符号表中 C 的条目的指针>
  <exp, op>
  <number, 整数值2>
  ```

注意
- 在某些对中，特别是运算符、标点符号和关键字的对中，不需要有属性值
- 这个例子中，词法单元 numbder 有一个整数属性值
- 实践中，编译器将保存一个代表该常量的字符串，并将该字符串的指针作为 number 的属性值

## 词法错误
例子
``` C
fi (a == f(x)) ...
```
- 第一次遇到 fi 时，无法指出 fi 究竟是关键字 if 的误写还是未声明的函数标识符
- 由于 fi 是标识符 **id** 的合法词素，因此词法分析器必须向语法分析器返回 **id** 词法单元
- 让编译器的另一个阶段（这个例子中是语法分析器）处理这个因为字母颠倒而引起的错误

__恐慌模式__
- 假设出现所有词法单元模式都无法和剩余输入的某个前缀相匹配的情况，词法分析器就不能继续处理输入
- 最简单的恢复策略：__恐慌模式__ 恢复
- 从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的词法单元为止
- 可能会给语法分析器带来混乱
- 但是在交互计算环境中，这个技术足够了

其它可能采取的错误恢复动作：
1. 从剩余的输入中删除一个字符
2. 向剩余的输入中插入一个遗漏的字符
3. 用一个字符替换另一个字符
4. 交换两个相邻的字符

这些变换可以试图修复错误输入时运行

*（为什么要修复错误输入呢？可能其实也没有必要？）*

## 3.1 节的练习
*略*

*（对于第2题，似乎应该把 html 标签的开头和结尾当作括号一样的东西处理（对于这本书目前的风格而言，似乎还没有出现过被“切断”的词素））*

# 输入缓冲
<i style="color:gray">对应扫描中文版pdf页码71</i>

讨论几种可以加快源程序读入速度的方法
- 我们将介绍一种双缓冲区方案，能够安全地处理向前看多个符号的问题
- 我们将考虑一种改进方法，使用 __哨兵标记__ 来节约用于检查缓冲区末端的时间

## 缓冲区对

## 哨兵标记


# 词法单元的规约
<i style="color:gray">对应扫描中文版pdf页码73</i>

# 词法单元的识别
<i style="color:gray">对应扫描中文版pdf页码80</i>

# 词法分析器生成工具 Lex
<i style="color:gray">对应扫描中文版pdf页码89</i>

# 有穷自动机
<i style="color:gray">对应扫描中文版pdf页码93</i>

# 从正则表达式到自动机
<i style="color:gray">对应扫描中文版pdf页码96</i>

# 词法分析器生成工具的设计
<i style="color:gray">对应扫描中文版pdf页码105</i>

# 基于 DFA 的模式匹配器的优化
<i style="color:gray">对应扫描中文版pdf页码109</i>

# 第 3 章总结
<i style="color:gray">对应扫描中文版pdf页码118</i>

[代目录](ReadMe.md#代目录)