[代目录](ReadMe.md#代目录)

本章内容
- 讨论如何构建一个词法分析器
- 建立每个词法单元的此法结构图或其它描述
- 编写代码识别输入中出现的每个词素，返回识别到的词法单元的有关信息

自动生成词法分析器
- 向一个 __词法分析器生成工具__（lexical-analyzer generator）描述词素的模式，将这些模式编译为具有词法分析器功能的代码
- 使得修改词法分析器的工作变得更加简单，因为只需要修改受到影响的模式，无需修改整个程序
- 加快词法分析器的实现速度，程序员只需要在很高的模式层次上描述软件，就可以依赖生成工具生成详细代码
- 我们将在 [3.5 节](ch3.md#词法分析器生成工具-lex)介绍一个名为 Lex 的词法分析器生成工具（它的一个最新变体称为 Flex）

在介绍词法分析器生成工具之前，我们先介绍正则表达式
- 正则表达式是一种可以很方便地描述词素模式的方法
- 将介绍如何对正则表达式进行转换
  - 首先转换为 __不确定有穷自动机__，然后再转换为 __确定有穷自动机__
  - 后两种表示方法可以作为一个“驱动程序”的输入
  - 这个驱动程序就是一段模拟这些自动机的代码
  - 它使用这些自动机确定下一个词法单元
  - 这个驱动程序以及对自动机的规约形成了词法分析器的核心部分

# 词法分析器的作用
<i style="color:gray">对应扫描中文版pdf页码68</i>

词法分析器
- 是编译的第一个阶段
- 它的主要任务是读入源程序的输入字符、将它们组成词素，生成并输出一个词法单元序列
  - 每个词法单元对应于一个词素
  - 这个词法单元序列被输出到语法分析器进行语法分析

语法分析器通常还要和符号表进行交互
- 当 __词法分析器__ 发现了一个标识符的词素时，它要将这个词素添加到符号表中
- 某些情况下，__词法分析器__ 会从符号表中读取有关标识符种类的信息，以确定向 __语法分析__ 器传送哪个词法单元
- 这种交互关系由图给出（*略*）
  - 通常交互是由 __语法分析器__ 调用 __词法分析器__ 实现的
  - 命令 `getNextToken` 所指的调用使得 __词法分析器__ 从它的输入中不断读取字符，直到它识别出下一个词素位置
  - __词法分析器__ 根据这个词素生成下一个词法单元并返回给 __语法分析器__

词法分析器的其它任务
- 过滤掉源程序中的注释和空白（空格、换行符、制表符、输入中用于分隔词法单元的其它字符）
- 将编译器生成的错误消息与源程序的位置联系起来
  - 例如，词法分析器可以负责记录遇到的换行符个数，以便给每个出错消息赋予一个行号
  - 某些编译器中，词法分析器会建立源程序的一个拷贝，并将出错消息插入到适当位置
  - 如果源程序使用了一个宏预处理器，则宏的扩展也可以有由词法分析器完成

有时，词法分析器可以分成两个级联的处理阶段
1. __扫描阶段__：主要负责不需要生成词法单元的简单处理，如删除注释和将多个连续空白字符压缩成一个字符
2. __词法分析阶段__：是较为复杂的部分，处理扫描阶段的输出并生成词法单元

## 词法分析器及语法分析
把编译过程的分析部分划分为 __词法分析__ 和 __语法分析__ 阶段有几个原因
1. 最重要的考虑是简化编译器设计
    - 通常使我们至少可以简化其中的一项任务
    - 例如，如果一个语法分析器必须把空白符和注释当作语法单元处理，那么它会比假设空白和注释符已经被词法分析器过滤掉的处理器复杂得多
    - 分开考虑有助于得到更加清晰的语言设计方案
2. 提高编译器效率
    - 使我们能够使用专用于词法分析任务、不进行语法分析的技术
    - 可以使用专门的用于读取输入字符的缓冲技术，显著提高编译器的速度
3. 增强编译器的可移植性
    - 输入设备相关的特殊性可以被限制在词法分析器中

## 词法单元、模式和词素
三个相关但区别的术语
1. __词法单元__
   - 由一个词法单元名和一个可选的属性组成
   - 词法单元名是一个表示某种词法单位的抽象符号，比如
     - 特定的关键字
     - 代表标识符的输入字符序列
   - 词法单元名字是由 __语法分析器__ 处理的输入符号
2. __模式__
   - 描述了一个词法单元的词素可能具有的形式
   - 当词法单元是一个关键字时，它的模式就是组成这个关键字的字符序列
   - 对于标识符和其它词法单元，模式是一个更加复杂的结构，可以和很多符号串 __匹配__\
     *（haskell的parsec库中的parser是不是用来识别“模式”的呢？）*
3. __词素__
   - 源程序的一个字符序列
   - 和某个词法单元的模式匹配，并被词法分析器识别为该词法单元的一个实例

例子：给出了常见的词法单元、非正式描述的词法单元的模式，一些示例词素
| 词法单元 | 非正式描述 | 词素示例 |
|---|---|---|
|**if**|字符 i, f|if|
|**else**|字符 e, l, s, e|else|
|**comparison**|< 或 > 或 >= 或 == 或 !=|<=, !=|
|**id**|字母开头的字母/数字串|pi, score, D2|
|**number**|任何数字常量|3.14149, 0, 6, 02e23|
|**literal**|在两个 `"` 之间，除 `"` 以外的任何字符|"core dumped"|

很多程序设计语言中，下面的类别覆盖了大部分或所有词法单元
1. 每个关键字有一个词法单元。一个关键字的模式就是该关键字本身
2. 表示运算符的词法单元。它可以表示单个运算符，也可以像例子里面的 **comparison** 那样，表示一类运算符
3. 一个表示所有标识符的词法单元
4. 一个或多个表示常量的词法单元，比如数字和字面值字符串
5. 每个标点符号有一个词法单元，比如左右括号、逗号和分号

*（上面的词法单元的模式似乎都只涉及到在文本中连续的字符序列，可能在这里，haskell里面的parsec库与普通的方式之间存在区别）*

## 词法单元的属性

## 词法错误

## 3.1 节的练习


# 输入缓冲
<i style="color:gray">对应扫描中文版pdf页码71</i>

# 词法单元的规约
<i style="color:gray">对应扫描中文版pdf页码73</i>

# 词法单元的识别
<i style="color:gray">对应扫描中文版pdf页码80</i>

# 词法分析器生成工具 Lex
<i style="color:gray">对应扫描中文版pdf页码89</i>

# 有穷自动机
<i style="color:gray">对应扫描中文版pdf页码93</i>

# 从正则表达式到自动机
<i style="color:gray">对应扫描中文版pdf页码96</i>

# 词法分析器生成工具的设计
<i style="color:gray">对应扫描中文版pdf页码105</i>

# 基于 DFA 的模式匹配器的优化
<i style="color:gray">对应扫描中文版pdf页码109</i>

# 第 3 章总结
<i style="color:gray">对应扫描中文版pdf页码118</i>

[代目录](ReadMe.md#代目录)