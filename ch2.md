[代目录](ReadMe.md#代目录)

本章内容
- 对本书[第3章]至[第6章]中介绍编译技术的总体介绍
- 通过开发一个可运行Java程序演示这些编译技术
- 可以将具有代表性的程序设计语言翻译为三地址代码
- 重点是编译器的前端，特别是词法分析/语法分析/中间代码生成
- [第7章]和[第8章]将介绍如何根据三地址代码生成机器指令
- 从小事做起，建立一个将中级算数表达式转换为后缀表达式的语法制导翻译器
- 扩展这个翻译器，使它能够将某些程序片段转换为三地址代码

# 引言
<i style="color:gray">对应扫描中文版pdf页码24</i>

__语法__
- 分析阶段的工作是围绕“语法”展开的
- 一个程序式设计语言的 __语法__ （syntax）描述了该语言程序的正确形式
- __语义__（semantics）定义了程序的含义

__上下文无关文法__ 或 __BNF__（backus-naur范式）
- 描述语法的一个广泛使用的表示方法
- 不仅可以描述一个语言的语法，还可以指导程序翻译的过程\
  *（在EOPL（编程语言要领）里面也是这样的）*
- 在2.3节中，我们将介绍一种面向文法的翻译技术，__语法制导翻译__（syntax-directed translation）\
  *（应该是翻译的问题，应该翻译成语法导向翻译）*
- 语法扫描，或者语法分析，将在2.4节中介绍

使用现有语义表示方法来描述一个语言的语义难度远远大于描述语言语法的难度

本章其余部分快速浏览编译器前端模型
- 首先介绍语法分析器
- 首先考虑从中缀表达式到后缀表达式的语法制导翻译过程
- 将表达式翻译为后缀形式的过程可以充分演示语法分析技术，同时这个翻译过程又很简单
- 我们将在第2.5节中给出翻译器的全部程序

__标识符__
- 语法分析器使得翻译器可以处理由多个字符组成的构造，比如标识符
- 标识符由多个字符组成，但是在语法分析阶段被当作一个单元，这样的单元称作 __词法单元__（token）

中间代码生成
- 抽象语法树：表示了源程序的层次化语法结构；
- 语法分析器生成一棵语法树，它又被进一步翻译为三地址代码
- 有些编译器会将语法分析和中间代码生成合并为一个组件

# 语法定义
<i style="color:gray">对应扫描中文版pdf页码25</i>

- 这一节将介绍描述程序设计语法的表示方法：__上下文无关文法__
- 本书中，文法将被用于组织编译器前端

文法
- 自然地描述了大多数程序设计构造的层次化语法结构
- `if (expression) statement else statement`
  - 用 `expr` 表示表达式，用变量 `stmt` 表示语句
  - `stmt -> if (expr) stmt else stmt`
  - 其中的箭头可以读作“可以具有如下形式”
- 这样的规则称为 __产生式__（production）
- 一个产生式中，关键字 `if` 和括号这样的词法元素称为 __终结符号__（terminal）
- 像 `expr` 和 `stmt` 这样的变量，称为 __非终结符号__（nonterminal）\
  *（尚可继续代换的即“非终结”，无法再代换的即“终结”）*

## 文法定义
__上下文无关文法__ 的组成四元素
1. 终结符号集合，有时也称“词法单元”，是该文法所定义的语言的基本符号的集合
2. 非终结符号集合，有时也称“语法变量”。每个非终结符号表示一个终结符号的集合
3. 一个产生式集合
    - 包括
      - 一个 __产生式头部__ 或 者 __左部__ 的非终结符号
      - 一个箭头
      - 一个 __产生式体__ 或 __右部__ 的由终结符号及非终结符号组成的序列
    - 产生式主要用来表示某个构造的某种书写方式\
      *（既然是书写方式，是不是说要遵循源语言书写的习惯？）*
4. 指定一个非终结符号为 __开始符号__

<div style="border:1px solid;padding:10px">

**词法单元和终结符号**

编译器中，词法分析器
- 读入源程序的字符序列
- 组织为具有词法含义的词素
- 输出代表词素的词法单元序列

词法单元组成
1. 名字：
    - 语法分析器进行语法分析使用的抽象符号
    - 常常称为 __终结符号__
2. 属性值：
    - 如果词法单元具有属性值，囊二这个值就是指向符号表的指针
    - 符号表包含了该词法单元的附加信息，通常不是文法的组成部分
    - 我们在讨论语法分析时，通常将词法单元和终结符号当作同义词

</div>

描述文法时
- 我们会列出文法的产生式
- 首先列出开始符号对应的产生式
- 为表示方便，以同一个终结符号为头部的多个产生式的体可以放在一起表示，不同体之间用符号 `|`（读作“或”）分隔

描述文法的习惯（续）
- 如果某个非终结符号是某个产生式的头部，我们说该产生式是该非终结符号的产生式
- 零个终结符号组成的串称为 __空串__（empty string），记为 $\epsilon$

## 推导
根据文法推导符号时
- 从开始符号出发，不断将某个非终结符号替换为该非终结符号的某个产生式的体
- 可以从开始符号推导得到所有终结符号串的集合，称为该文法定义的 __语言__

*（从一般到特殊，从文法的规则，推导出具体的一串符号序列；所有凡是可能的序列，统称为语言）*

__语法分析__ 的任务
- 接受一个终结符号串作为输入，找出从文法开始符号推导出这个串的方法
- 如果不能从文法的开始符号推导得到该终结符号串，则报告该终结符号串中包含的语法错误

*（有点逆向求解问题的感觉）*

预告
- 主要语法分析方法将在第4章中讨论
- 本章中，为简单起见，首先处理像 `9 - 5 + 2` 这样的源程序，其中每个字符均为一个终结符号\
  *（其实，语法分析这个步骤，它真正的输入应该是“符号流”，也就是词法分析的输出，而不是真正的字符串；前面文法里面的“终结/非终结符号”，应该都属于“符号流”）*
- 一般情况下，一个源程序会包含由多个字符组成的词素，这些词素由词法分析器组成词法单元，而词法单元的第一个分量就是被语法分析器处理的终结符号

## 语法分析树
语法分析树
- 用图形的方式展现了从文法的开始符号推导出响应语言中符号串的过程

正式地讲，给定一个上下文无关文法，该文法的一颗语法分析树具有以下性质
1. 根节点的符号为文法的开始符号
2. 每个叶子结点的标号为一个终结符号或 $\epsilon$
3. 每个内部结点的标号为一个非终结符号
4. 如果非终结符号A是某个内部结点的标号，并且它的子结点标号从左到右分别为 $X_1,X_2,\cdots,X_n$
    - 那么必然存在产生式 $A\rightarrow X_1X_2\cdots,X_n$ 其中 $X_1,X_2,\cdots,X_n$ 既可以是终结符号，又可以是非终结符号
    - 作为一种特殊情况，如果 $A\rightarrow\epsilon$ 是一个产生式，那么一个标号为A的结点可以只有一个标号为 $\epsilon$ 的子结点

<div style="border:1px solid;padding:10px">

**关于树形结构的术语**
- 一棵树由 __结点__（node） 组成
  - 结点可以带有标号（label）
  - 本书中标号通常是文法符号
  - 当我们画一棵树时，常常只用这些标号代表相应的结点
- 树有且仅有一个根（root）结点……

*略*

</div>

一颗语法分析树的叶子结点从左向右构成了树的 __结果__（yield）
- 也就是从这棵语法分析树的根结点上的非终结符号推导得到的符号串
- 任何树的叶子结点都有一个自然的从左到右的顺序

__语法分析__
- 一个文法的语言的另一个定义：任何能够从某棵语法分析树生成的符号串的集合
- 为一个给定的终结符号串构建一棵语法分析树的过程称为对符号串进行 __语法分析__

## 二义性
二义性
- 一个文法可能有多棵语法分析树能够生成同一个给定的终结符号串
- 这样的文法称为具有 __二义性__（ambiguous）
- 要证明一个文法具有二义性，我们只需要找到一个终结符号串，说明它是两棵以上语法分析树的结果
- 对策
  - 需要为编译应用设计出没有二义性的文法
  - 或者在使用二义性文法时使用附加的规则消除二义性

## 运算符的结合性
结合性
- 当一个运算分量的左右两侧都有运算符时，我们需要一些规则来决定哪个运算符被应用于该运算分量
- __左结合__（associate）：当一个运算分量左右都有 `+`，它属于其左边的运算符
- 大多数程序设计语言中，加、减、乘、除四种运算符都是左结合的\
  *（左、右结合性影响的是，在一串同等优先级的运算符之间加括号，应该优先在左边积累括号）*\
  *（左右结合性和运算符对应的函数入口参数与运算符左右分量的对应位置之间无关）*
- 某些常用运算符是右结合的
  - 指数运算
  - C语言中的赋值运算符“=”及其后裔
- 带有右结合的串，比如 `a = b = c`，可以由如下文法产生：
  ```
  right -> letter = right | letter
  letter -> a | b | ... | z
  ```
- 左结合运算符的语法分析树向左下端延伸，右结合运算符的语法分析树向右下端延伸

## 运算符的优先级
举例
- 考虑表达式 `9 + 5 * 2`。该表达式有两种可能的解释，即 `(9 + 5) * 2` 或 `9 + (5 * 2)`
- `+` 和 `*` 的结合性规则只能作用于同一运算符的多次出现，因此它们无法解决这个二义性
- 当多种运算符出现时，我们需要给出一些规则定义运算符的相对优先关系\
  *（能否说运算符优先级的出现是为了解决一部分二义性？）*
- 如果 `*` 优先于 `+` 获得运算分量，就说 `*` 比 `+` 具有 __更高的优先级__

举例：
- 算数表达式的文法可以根据表示运算符结合性和优先级的表格来构建\
  *（haskell的parsec库似乎包含了这种表格的表达方式，能够处理文法）*\
  *（优先级表应该就是上面说的消除二义性的附加规则）*
- 考虑四个常用运算符和一个优先级表
- 创建两个非终结符号 `expr` 和 `term`，分别对应于这两个优先级层次
- 使用另一个非终结符号 `factor` 生成表达式中的基本单元
  - 当前表达式的基本单元是数位和带括号的表达式
  - `factor -> digit | (expr)`
- 考虑具有最高优先级的 `*` 和 `/`，由于运算符是左结合的，因此产生式和左结合列表产生式类似
  - ```
    term -> term * factor
          | term / factor
          | factor
    ```
- 类似地，`expr` 生成由加减运算符分隔的 `term` 列表
  - ```
    expr -> expr + term
          | expr - term
          | term
    ```
- 最终得到的文法是：*略*

<div style="border:1px,solid;padding:10px">

**上面举例中表达式文法的推广**
- 将 __因子__（factor）理解成不能被任何运算符分开的表达式
  - “不能分开”是指在任意因子的任意一边放置一个运算符，都不会导致这个因子的任何部分分离出来，成为这个运算符的分量
  - 因子本身作为一个整体可以成为该运算符的一个运算分量
  - 如果这个因子是一个由括号括起来的表达式，那么括号将起到保护其不被分开的作用
- 不是因子的 __项__（term）
  - 一个可能被高优先级的运算符分开，但不能被低优先级运算符分开的表达式
  - 一个不是因子或项的表达式可能被任何一个运算符分开
- 推广到具有n层优先级的情况，需要n+1个非终结符号
  - 通常，这个非终结符号的产生提只能是单个运算分量或括号括起来的表达式\
    *这句话应该是表示相对“不可分割”的特点*
  - 对于每个优先级都有一个非终结符号，表示能被该优先级或更高优先级的运算符分开的表达式
  - 通常，这个非终结符号的产生式
    - 有一些产生式体表示了该优先级的运算符的应用
    - 另有一个产生式体只包含了代表更高一层优先级的非终结符号\
    *（`factor` 也可以当作 `term` 的一种情况，更高优先级的一层也可以当作更低优先级的层次来用）*
</div>

举例：*略*

## 2.2节的练习
*略*

*（练习2.2.6为罗马数字构建一个上下文无关文法似乎很有意思）*

# 语法制导翻译
<i style="color:gray">对应扫描中文版pdf页码32</i>

语法制导翻译：通过向一个文法的产生式附加一些规则或程序片段得到
- 考虑一个由如下产生式生成的表达式 `expr`\
  `expr -> expr1 + term`
- `expr` 是两个子表达式 `expr1` 和 `term` 的和（`expr1` 中的下标只是表示区分）
- 利用 `expr` 的结构，用如下伪代码翻译 `expr`\
  ```
  翻译 expr1;
  翻译 term;
  处理 +;
  ```
- 我们将在[2.8节](ch2.md#生成中间代码)中使用这段伪代码的一个变体，为 `expr` 构造一颗语法分析树
  - 首先建立 `expr1` 和 `term` 的语法分析树
  - 然后处理 `+` 运算符并构造得到一个和此运算符对应的结点
- 为方便起见，本节的例子是从中缀表达式得到后缀表达式的翻译

本节介绍两个与语法制导翻译相关的概念：
- __属性__（attribute）：表示与某个程序构造相关的任意量
  - 属性可以是多种多样的：数据类型、生成代码中的指令数目、为某个构造生成的代码中第一条指令的位置
  - 因为我们用文法符号（终结符号/非终结符号）表示程序构造，所以将属性的概念从程序构造扩展到表示这些构造的文法符号上
- __翻译方案__（translation scheme）：一种将程序片段附加到一个文法的各个表达式上的表示法
  - 当在语法分析过程中使用一个产生式时，响应的程序片段就会执行
  - 程序片段的执行效果按照语法分析过程的顺序组合起来，得到的结果就是这次分析/综合处理源程序得到的翻译结果\
  *（说得太过晦涩难懂了，不过我猜就是EOPL（编程语言要领）中说的按照文法的规则、递归地处理）*

语法制导翻译方案将在本章多次使用
- 把中缀表达式翻译成后缀表达式
- 用于表达式求值，并用来构建一些程序构造的抽象语法树
- [第5章](ch5.md)将更详细地讨论语法制导表示法

## 后缀表示
本节的例子：中缀表达式到其后缀表示的翻译

一个表达式的 __后缀表示__（postfix notation）
1. 如果E是一个变量或常量，则E的后缀表示是E本身
2. 如果E是一个形如 $E_1\bold{op}E_2$的表达式，其中op是一个二目运算符，那么E的后缀表示是 $E'_1E'_2\bold{op}$，这里E'1和E'2分别是E1和E2的后缀表示
3. 如果E是一个形如 $(E_1)$ 的被括号括起来的表达式，则E的后缀表示就是E1的后缀表示

*（其实这个倒不用太纠结，只是具体实现之前可能需要列出来）*

例子：*略*

例子：*略*

## 综合属性
将量和程序关联起来（例如把数值/类型和表达式相关联）的想法可以基于文法表示
- 将属性和文法的非终结符号及终结符号相关联
- 给文法的各个产生式附加语义规则
- 对于语法分析树的一个结点，如果它和它的子结点之间的关系符合某个产生式，那么该产生式对应的规则就描述了如何计算这个结点上的属性

*（很扯，有必要这么晦涩吗？感觉是在说求值的过程，还是先求局部，后求整体）*

__语法制导定义__（syntax-directed definition）
1. 把每个文法符号和一个属性集合相关联
2. 把每个产生式和一组 __语义规则__（semantic rule）相关联，这些规则用于计算与该产生式中符号相关联的属性值

属性可以按照如下方式求值
- 对于给定的输入串x，构建x的一个语法分析树
- 按照下面的方法应用语义规则来计算语法分析树中各个结点的属性
  - 假设语法分析树的一个结点N的标号为文法符号X
  - 用X.a表示该结点上X的属性a的值
  - 如果一棵语法分析树的各个结点上标记了相应的属性值，那么这棵语法分析树就称为 __注解__（annotated）语法分析树（简称注解分析树）\
    *（原文把annotated翻译成“注释”（comment），感觉非常不利于理解）*

图中显示一棵注解分析树
- 9-5+2的一棵注解分析树
  ```
  expr.t = 95-2+
  ├─ expr.t = 95-
  │  ├─ expr.t = 9
  │  │  └─ term.t = 9
  │  │     └─ 9 ....... (9)
  │  ├─ - ............. (-)
  │  └─ term.t = 5
  │     └─ 5 .......... (5)
  ├─ + ................ (+)
  └─ term.t = 2
     └─ 2 ............. (2)
  （转绘过程中，原本的从左往右的叶子结点，现在变成从上往下）
  ```
- 属性t与非终结符号 `expr` 和 `term` 关联
- 该属性在根结点处的值为 `95-2+`，也就是 `9 - 5 + 2` 的后缀表示
- 我们很快会看到这些表达式的计算方法

*（所谓属性，看起来就是“求值结果”，或者是希望从语法分析树中得到的结果，例子中是从语法分析树中得到后缀表达式；这种方式表示的语法分析树的特点是容易验证，但似乎暂时并没有说明如何获得该树；除此以外，仍然表明了根节点的计算要依据子节点的计算结果）*

__综合属性__（synthesized attribute）
- 如果某个属性在语法分析树结点N上的值是由N的子节点以及N本身的属性值确定的\
  ~~*（你在开玩笑吗？“属性在结点N上的值”，一部分决定于“N本身的属性值”？自己决定自己？）*~~\
  *（可能翻译有问题，这里应该是指，结点N本身带有如何把子节点的结果“综合”起来的规则描述）*
- 那么这个属性就称为 __综合属性__

综合属性具有一个很好的性质：只需要对语法分析树进行一次自底向上的遍历，就可以计算出属性的值

预告：
- 在5.1.1节中，我们将讨论另外一种重要的属性：“继承”属性
- 通俗地讲，继承属性在某个语法分析树结点上的值是由语法分析树中该结点本身、父节点以及兄弟结点上的属性值决定的

*（明白了，这是在说明，并不是所有所谓“属性”都能够通过自底向上遍历树的方式，方便地计算。也就是说，只有“综合属性”才能这样做。所谓“综合”的含义应该是指，“取自后代，将结果进行综合”）*

例子：前面所说图中注解分析树是根据 __语法制导定义__ 得到的
- 定义
  |产生式|语义规则|
  |-|-|
  |`expr->expr1+term`|`expr.t=expr1.t\|\|term.t\|\|'+'`|
  |`expr->expr1-term`|`expr.t=expr1.t\|\|term.t\|\|'-'`|
  |`expr->term`|`expr.t=term.t`|
  |`term->0`|`term.t='0'`|
  |`term->1`|`term.t='1'`|
  |...|...|
  |`term->9`|`term.t='9'`|
- 该定义用于把一个表达式翻译为该表达式的后缀形式
- 待翻译的表达式是一个由加号和减号分隔的数位序列
- 图中每个非终结符号有一个值为字符串的属性t，表示由该非终结符号生成的表达式的后缀表示形式
- 语义规则中的符号 `||` 表示字符串的连接运算符\
  *（明白了，所谓语法制导定义，应该是属于语义分析这一块，其输入为语法树，输出为另一语法树）*
- 规则解释：*略*

<div style="border:1px,solid;padding:10px">

**区分一个非终结符号的不同使用的规则**
- 在规则中，经常要区分一个非终结符号在产生式的头和/或体中的使用
- 原因是，语法分析树中，标号为同一非终结符号的不同结点通常在翻译中具有不同的属性值

我们将采用规则
- 出现在式头的非终结符号没有下标
- 在产生式体的非终结符号带有不同的下标
- 同一个非终结符号的所有出现都按照这种方式区分
- 下标不是名字的组成部分

</div>

## 简单语法制导定义
__简单__（simple）语法制导定义：
- 上面的例子中，要得到代表产生式头部的非终结符号翻译结果的字符串
- 只需要将产生式体中各非终结符号的翻译结果按照它们在非终结符号中的出现顺序连接起来
- 并在其中穿插一些附加串即可
- 具有这个性质的语法制导定义，称为简单语法制导定义

例子：*略*

当讨论翻译方案的时候，我们将看到，一个简单语法制导定义的实现很简单，只需要按照它们在定义中出现的顺序打印出附加的串即可

## 树的遍历
树的遍历将用于描述
- 属性的求值过程
- 一个翻译方案中各个代码片段的执行过程

树的遍历从根节点开始，按照某个顺序访问树的各个结点

__深度优先__（depth-first）遍历：
- 从根结点开始，递归地按照任意顺序访问各个结点的子结点
- 并不一定要按照从左到右的顺序遍历
- 这种遍历总是尽可能地访问一个结点尚未被访问的子节点，尽可能地访问离根结点最远的结点（最深的结点）

__语法制导定义__ 并没有规定一棵语法分析树的各个属性值的求值顺序
- 只要一个顺序能够保证计算属性a的值时，a所依赖的其他属性都已经计算完毕，这个顺序就是可以接受的
- __综合属性__ 可以在 __自底向上__ 遍历的时候计算
- 一般来说，当既有 __综合属性__ 又有 __继承属性__ 时，关于求值顺序的问题便能的相当复杂，参见5.2节

## 翻译方案
我们考虑另一种不需要操作字符串的方法（不同于之前翻译方案的例子），通过运行程序片段，逐步生成相应的翻译结果

<div style="border:1px,solid;padding:10px">

**前序遍历和后序遍历**
- 是深度优先遍历的两种重要特例
- 这两种遍历中，我们都是从左到右递归地访问每个结点的子节点
- 遍历一棵树，并在各个结点上执行某些动作
  - __前序遍历__：动作在我们第一次访问同一个结点时被执行
  - __后序遍历__：动作在我们最后离开一个结点前被执行

前序遍历和后续遍历根据一个结点的动作执行时间来定义这些结点的相应次序
- 一棵以结点N为根的（子）树
- __前序排序__：由N，跟上它的从左到右每棵子树（如果存在）的前序排序组成
- __后序排序__：由N的从左到右的每棵子树的后续排序，再跟上N自身组成

*（我怀疑这里说的不是排序，而是扁平化）*

*（所谓前序后序，大概是指根结点处理的时机：前序：如果先处理根结点，后往下钻；后序：先往下钻，后处理根结点）*
</div>

__语法制导翻译方案__
- 是一种在文法产生式中附加一些程序片段来描述翻译结果的表示方法
- 与 __语法制导定义__ 相似，只是显式地制定了语义规则的计算顺序

__语义动作__（semantic action）
- 被嵌入到产生式体中的程序片段
- 一个语义动作用花括号括起来，并写入产生式的体中
- 它的执行位置也由此指定
- 例如：`rest -> + term {print('+')} rest1`
- 当我们考虑表达式的另一种形式的文法时，我们就会看到这样的规则
- 这种文法形式将在2.4.5节中讨论

当我们画出一个翻译方案的语法分析树时
- 我们为每个语义动作构造一个额外的子节点，使用虚线将它和该产生式头部对应的结点相连

*（__语法制导翻译方案__ 和 __语法制导定义__ 到底是什么关系？）*

例子：
- 语法分析树在额外的叶子结点含有打印语句
  ```
  expr
  ├─ expr
  │  ├─ expr
  │  │  └─ term
  │  │     ├─ 9 ....... (9)
  │  │     ╚═ {print('9')}
  │  ├─ - ............. (-)
  │  ├─ term
  │  ║  ├─ 5 .......... (5)
  │  ║  ╚═ {print('5')}
  │  ╚═ {print('-')}
  ├─ + ................ (+)
  ├─ term
  ║  ├─ 2 ............. (2)
  ║  ╚═ {print('2')}
  ╚═ {print('+')}
  （转绘过程中，原本的从左往右的叶子结点，现在变成从上往下）
  ```
  *（上面的print执行完之后，又变成希望翻译出来的后缀表达式了）*
- 根结点代表第一个产生式
- 根结点最左边的子树代表左边的运算分量，它的标点符号和根结点一样都是 `expr`
- 在一次后序遍历中
  - 首先执行该子树的所有语义动作
  - 然后访问没有语义动作的叶子节点 `+`
  - 接下来，执行代表右运算分量 `term` 的子树中的所有语义动作
  - 最后执行额外结点上的语义动作 `{print('+')}`
- 由于 `term` 的产生式的右部只有一个数位，该产生式的语义动作把这个数位打印出来
- 产生式 `expr->term` 不需要产生输出，只有前面两个产生式的语义动作中的运算符才会打印出来
- 语义动作会在分析树的后序遍历中执行时打印出`9 5 - 2 +`

介绍 __语法制导定义__ 使用到的树和介绍该 __语法制导翻译方案__ 时使用到的树，尽管产生结果相同，但构造过程不同
- 前者是把字符串作为属性附加到语法分析树的结点上
- 后者通过语义动作把翻译结果以增量的方式打印出来

实现一个翻译方案时，必须保证各个语义动作按照它们在语法分析树的后序遍历中的顺序执行
- 不一定真的要构造出一棵语法分析树（通常也不会）
- 只要能够确保语义动作的执行过程等同于我们真的构造了语法分析树，并在后序遍历中执行这些动作即可

*（为什么？ __翻译方案__ 一定要用/等同于后序遍历吗？）（我怀疑原因在于要获得后缀表达式的这个“目的”；这是因为，无论希望获得前缀表达式还是后缀表达式，都不影响源语言如何被扫描、解析，如何生成语法分析树，归根结底，“后缀表达式”这个结果，是在语义分析这一步出现的）*

*（如果我不希望打印出来，不希望有副作用，该怎么办呢？）*

## 2.3节的练习
*略*

# 语法分析
<i style="color:gray">对应扫描中文版pdf页码37</i>

__语法分析__
- 是决定如何使用一个文法生成一个终结符号串的过程\
  *（和我之前说得一样，有点逆向提问题的感觉，符号串是“输入”，被当作“结果”，而语法分析树是“输出”，也就是我们想知道的“过程”）*
- 尽管在实践中编译器并没有真的构造出这棵树，然而原则上语法分析器必须能够构造出语法分析树，否则将无法保证翻译的正确性

预告
- 本节介绍 __递归下降__：一种语法分析方法，该方法可用于语法分析和实现语法制导翻译器
- 下一节将给出一个实现了前述打印出 `"95-2+"` 字符串的翻译方案的完整Java程序；另一种可行方法是使用软件工具直接根据翻译方案生成一个翻译器
- 4.9 节将描述这样的一个工具 Yacc。使用这个工具，无需修改就可以实现前面说的翻译方案

效率
- 对于任何上下文无关文法，我们都可以构造出一个时间复杂度为 O(n^3) 的语法分析器
- 它最多使用 O(n^3) 的时间就可以完成一个长度为 n 的符号串的语法分析
- 但是，三次方的时间代码一般太昂贵了
- 对于实际程序设计语言而言，我们通常能够设计出一个被高效分析的文法\
  *（“通常能”，是说能不能高效分析，可能和设计的文法有关是吗？）*
- 线性时间复杂度的算法足以分析实践中出现的各种程序设计语言
- 程序设计语言的语法分析器几乎总是一次性地从左到右扫描输入，每次向前看一个终结符号，并在扫描时构造出分析树的各个部分

大多数语法分析方法都可以归入以下两类：
- __自顶向下__（top-dowm）
  - 构造过程从根结点开始，逐步向叶子结点方向进行
- __自底向上__（bottom-up）
  - 构造过程从叶子结点开始，逐步构造出根结点

比较
- __自顶向下__ 语法分析器之所以受欢迎，是使用这种方法可以较容易地手工构造出高效的语法分析器
- __自底向上__ 分析方法可以处理更多文法和翻译方法，所以直接从文法生成语法分析器的软件工具常常使用自底向上的方法

## 自顶向下分析法

## 预测分析法

## 何时使用 ε 产生式

## 设计一个预测分析器

## 左递归

## 2.4节的练习

# 简单表达式的翻译器
<i style="color:gray">对应扫描中文版pdf页码43</i>

# 词法分析
<i style="color:gray">对应扫描中文版pdf页码47</i>

# 符号表
<i style="color:gray">对应扫描中文版pdf页码53</i>

# 生成中间代码
<i style="color:gray">对应扫描中文版pdf页码57</i>

# 第2章总结
<i style="color:gray">对应扫描中文版pdf页码66</i>


[代目录](ReadMe.md#代目录)