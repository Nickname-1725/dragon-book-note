[代目录](ReadMe.md#代目录)

本章内容
- 对本书[第3章]至[第6章]中介绍编译技术的总体介绍
- 通过开发一个可运行Java程序演示这些编译技术
- 可以将具有代表性的程序设计语言翻译为三地址代码
- 重点是编译器的前端，特别是词法分析/语法分析/中间代码生成
- [第7章]和[第8章]将介绍如何根据三地址代码生成机器指令
- 从小事做起，建立一个将中级算数表达式转换为后缀表达式的语法制导翻译器
- 扩展这个翻译器，使它能够将某些程序片段转换为三地址代码

# 引言
<i style="color:gray">对应扫描中文版pdf页码24</i>

__语法__
- 分析阶段的工作是围绕“语法”展开的
- 一个程序式设计语言的 __语法__ （syntax）描述了该语言程序的正确形式
- __语义__（semantics）定义了程序的含义

__上下文无关文法__ 或 __BNF__（backus-naur范式）
- 描述语法的一个广泛使用的表示方法
- 不仅可以描述一个语言的语法，还可以指导程序翻译的过程\
  *（在EOPL（编程语言要领）里面也是这样的）*
- 在2.3节中，我们将介绍一种面向文法的翻译技术，__语法制导翻译__（syntax-directed translation）\
  *（应该是翻译的问题，应该翻译成语法导向翻译）*
- 语法扫描，或者语法分析，将在2.4节中介绍

使用现有语义表示方法来描述一个语言的语义难度远远大于描述语言语法的难度

本章其余部分快速浏览编译器前端模型
- 首先介绍语法分析器
- 首先考虑从中缀表达式到后缀表达式的语法制导翻译过程
- 将表达式翻译为后缀形式的过程可以充分演示语法分析技术，同时这个翻译过程又很简单
- 我们将在第2.5节中给出翻译器的全部程序

__标识符__
- 语法分析器使得翻译器可以处理由多个字符组成的构造，比如标识符
- 标识符由多个字符组成，但是在语法分析阶段被当作一个单元，这样的单元称作 __词法单元__（token）

中间代码生成
- 抽象语法树：表示了源程序的层次化语法结构；
- 语法分析器生成一棵语法树，它又被进一步翻译为三地址代码
- 有些编译器会将语法分析和中间代码生成合并为一个组件

# 语法定义
<i style="color:gray">对应扫描中文版pdf页码25</i>

- 这一节将介绍描述程序设计语法的表示方法：__上下文无关文法__
- 本书中，文法将被用于组织编译器前端

文法
- 自然地描述了大多数程序设计构造的层次化语法结构
- `if (expression) statement else statement`
  - 用 `expr` 表示表达式，用变量 `stmt` 表示语句
  - `stmt -> if (expr) stmt else stmt`
  - 其中的箭头可以读作“可以具有如下形式”
- 这样的规则称为 __产生式__（production）
- 一个产生式中，关键字 `if` 和括号这样的词法元素称为 __终结符号__（terminal）
- 像 `expr` 和 `stmt` 这样的变量，称为 __非终结符号__（nonterminal）\
  *（尚可继续代换的即“非终结”，无法再代换的即“终结”）*

## 文法定义
__上下文无关文法__ 的组成四元素
1. 终结符号集合，有时也称“词法单元”，是该文法所定义的语言的基本符号的集合
2. 非终结符号集合，有时也称“语法变量”。每个非终结符号表示一个终结符号的集合
3. 一个产生式集合
    - 包括
      - 一个 __产生式头部__ 或 者 __左部__ 的非终结符号
      - 一个箭头
      - 一个 __产生式体__ 或 __右部__ 的由终结符号及非终结符号组成的序列
    - 产生式主要用来表示某个构造的某种书写方式\
      *（既然是书写方式，是不是说要遵循源语言书写的习惯？）*
4. 指定一个非终结符号为 __开始符号__

<div style="border:1px solid;padding:10px">

**词法单元和终结符号**

编译器中，词法分析器
- 读入源程序的字符序列
- 组织为具有词法含义的词素
- 输出代表词素的词法单元序列

词法单元组成
1. 名字：
    - 语法分析器进行语法分析使用的抽象符号
    - 常常称为 __终结符号__
2. 属性值：
    - 如果词法单元具有属性值，囊二这个值就是指向符号表的指针
    - 符号表包含了该词法单元的附加信息，通常不是文法的组成部分
    - 我们在讨论语法分析时，通常将词法单元和终结符号当作同义词

</div>

描述文法时
- 我们会列出文法的产生式
- 首先列出开始符号对应的产生式
- 为表示方便，以同一个终结符号为头部的多个产生式的体可以放在一起表示，不同体之间用符号 `|`（读作“或”）分隔

描述文法的习惯（续）
- 如果某个非终结符号是某个产生式的头部，我们说该产生式是该非终结符号的产生式
- 零个终结符号组成的串称为 __空串__（empty string），记为 $\epsilon$

## 推导
根据文法推导符号时
- 从开始符号出发，不断将某个非终结符号替换为该非终结符号的某个产生式的体
- 可以从开始符号推导得到所有终结符号串的集合，称为该文法定义的 __语言__

*（从一般到特殊，从文法的规则，推导出具体的一串符号序列；所有凡是可能的序列，统称为语言）*

__语法分析__ 的任务
- 接受一个终结符号串作为输入，找出从文法开始符号推导出这个串的方法
- 如果不能从文法的开始符号推导得到该终结符号串，则报告该终结符号串中包含的语法错误

*（有点逆向求解问题的感觉）*

预告
- 主要语法分析方法将在第4章中讨论
- 本章中，为简单起见，首先处理像 `9 - 5 + 2` 这样的源程序，其中每个字符均为一个终结符号\
  *（其实，语法分析这个步骤，它真正的输入应该是“符号流”，也就是词法分析的输出，而不是真正的字符串；前面文法里面的“终结/非终结符号”，应该都属于“符号流”）*
- 一般情况下，一个源程序会包含由多个字符组成的词素，这些词素由词法分析器组成词法单元，而词法单元的第一个分量就是被语法分析器处理的终结符号

## 语法分析树
语法分析树
- 用图形的方式展现了从文法的开始符号推导出响应语言中符号串的过程

正式地讲，给定一个上下文无关文法，该文法的一颗语法分析树具有以下性质
1. 根节点的符号为文法的开始符号
2. 每个叶子结点的标号为一个终结符号或 $\epsilon$
3. 每个内部结点的标号为一个非终结符号
4. 如果非终结符号A是某个内部结点的标号，并且它的子结点标号从左到右分别为 $X_1,X_2,\cdots,X_n$
    - 那么必然存在产生式 $A\rightarrow X_1X_2\cdots,X_n$ 其中 $X_1,X_2,\cdots,X_n$ 既可以是终结符号，又可以是非终结符号
    - 作为一种特殊情况，如果 $A\rightarrow\epsilon$ 是一个产生式，那么一个标号为A的结点可以只有一个标号为 $\epsilon$ 的子结点

<div style="border:1px solid;padding:10px">

**关于树形结构的术语**
- 一棵树由 __结点__（node） 组成
  - 结点可以带有标号（label）
  - 本书中标号通常是文法符号
  - 当我们画一棵树时，常常只用这些标号代表相应的结点
- 树有且仅有一个根（root）结点……

*略*

</div>

一颗语法分析树的叶子结点从左向右构成了树的 __结果__（yield）
- 也就是从这棵语法分析树的根结点上的非终结符号推导得到的符号串
- 任何树的叶子结点都有一个自然的从左到右的顺序

__语法分析__
- 一个文法的语言的另一个定义：任何能够从某棵语法分析树生成的符号串的集合
- 为一个给定的终结符号串构建一棵语法分析树的过程称为对符号串进行 __语法分析__

## 二义性
二义性
- 一个文法可能有多棵语法分析树能够生成同一个给定的终结符号串
- 这样的文法称为具有 __二义性__（ambiguous）
- 要证明一个文法具有二义性，我们只需要找到一个终结符号串，说明它是两棵以上语法分析树的结果
- 对策
  - 需要为编译应用设计出没有二义性的文法
  - 或者在使用二义性文法时使用附加的规则消除二义性

## 运算符的结合性
结合性
- 当一个运算分量的左右两侧都有运算符时，我们需要一些规则来决定哪个运算符被应用于该运算分量
- __左结合__（associate）：当一个运算分量左右都有 `+`，它属于其左边的运算符
- 大多数程序设计语言中，加、减、乘、除四种运算符都是左结合的\
  *（左、右结合性影响的是，在一串同等优先级的运算符之间加括号，应该优先在左边积累括号）*\
  *（左右结合性通常应该不会决定运算符对应的函数入口参数的次序）*
- 某些常用运算符是右结合的
  - 指数运算
  - C语言中的赋值运算符“=”及其后裔
- 带有右结合的串，比如 `a = b = c`，可以由如下文法产生：
  ```
  right -> letter = right | letter
  letter -> a | b | ... | z
  ```
- 左结合运算符的语法分析树向左下端延伸，右结合运算符的语法分析树向右下端延伸

## 运算符的优先级
举例
- 考虑表达式 `9 + 5 * 2`。该表达式有两种可能的解释，即 `(9 + 5) * 2` 或 `9 + (5 * 2)`
- `+` 和 `*` 的结合性规则只能作用于同一运算符的多次出现，因此它们无法解决这个二义性
- 当多种运算符出现时，我们需要给出一些规则定义运算符的相对优先关系\
  *（能否说运算符优先级的出现是为了解决一部分二义性？）*
- 如果 `*` 优先于 `+` 获得运算分量，就说 `*` 比 `+` 具有 __更高的优先级__

举例：
- 算数表达式的文法可以根据表示运算符结合性和优先级的表格来构建\
  *（haskell的parsec库似乎包含了这种表格的表达方式，能够处理文法）*\
  *（优先级表应该就是上面说的消除二义性的附加规则）*
- 考虑四个常用运算符和一个优先级表
- 创建两个非终结符号 `expr` 和 `term`，分别对应于这两个优先级层次
- 使用另一个非终结符号 `factor` 生成表达式中的基本单元
  - 当前表达式的基本单元是数位和带括号的表达式
  - `factor -> digit | (expr)`
- 考虑具有最高优先级的 `*` 和 `/`，由于运算符是左结合的，因此产生式和左结合列表产生式类似
  - ```
    term -> term * factor
          | term / factor
          | factor
    ```
- 类似地，`expr` 生成由加减运算符分隔的 `term` 列表
  - ```
    expr -> expr + term
          | expr - term
          | term
    ```
- 最终得到的文法是：*略*

<div style="border:1px solid;padding:10px">

**上面举例中表达式文法的推广**
- 将 __因子__（factor）理解成不能被任何运算符分开的表达式
  - “不能分开”是指在任意因子的任意一边放置一个运算符，都不会导致这个因子的任何部分分离出来，成为这个运算符的分量
  - 因子本身作为一个整体可以成为该运算符的一个运算分量
  - 如果这个因子是一个由括号括起来的表达式，那么括号将起到保护其不被分开的作用
- 不是因子的 __项__（term）
  - 一个可能被高优先级的运算符分开，但不能被低优先级运算符分开的表达式
  - 一个不是因子或项的表达式可能被任何一个运算符分开
- 推广到具有n层优先级的情况，需要n+1个非终结符号
  - 通常，这个非终结符号的产生提只能是单个运算分量或括号括起来的表达式\
    *这句话应该是表示相对“不可分割”的特点*
  - 对于每个优先级都有一个非终结符号，表示能被该优先级或更高优先级的运算符分开的表达式
  - 通常，这个非终结符号的产生式
    - 有一些产生式体表示了该优先级的运算符的应用
    - 另有一个产生式体只包含了代表更高一层优先级的非终结符号\
    *（`factor` 也可以当作 `term` 的一种情况，更高优先级的一层也可以当作更低优先级的层次来用）*
</div>

举例：*略*

## 2.2节的练习
*略*

*（练习2.2.6为罗马数字构建一个上下文无关文法似乎很有意思）*

# 语法制导翻译
<i style="color:gray">对应扫描中文版pdf页码32</i>

语法制导翻译：通过向一个文法的产生式附加一些规则或程序片段得到
- 考虑一个由如下产生式生成的表达式 `expr`\
  `expr -> expr1 + term`
- `expr` 是两个子表达式 `expr1` 和 `term` 的和（`expr1` 中的下标只是表示区分）
- 利用 `expr` 的结构，用如下伪代码翻译 `expr`\
  ```
  翻译 expr1;
  翻译 term;
  处理 +;
  ```
- 我们将在[2.8节](ch2.md#生成中间代码)中使用这段伪代码的一个变体，为 `expr` 构造一颗语法分析树
  - 首先建立 `expr1` 和 `term` 的语法分析树
  - 然后处理 `+` 运算符并构造得到一个和此运算符对应的结点
- 为方便起见，本节的例子是从中缀表达式得到后缀表达式的翻译

本节介绍两个与语法制导翻译相关的概念：
- __属性__（attribute）：表示与某个程序构造相关的任意量
  - 属性可以是多种多样的：数据类型、生成代码中的指令数目、为某个构造生成的代码中第一条指令的位置
  - 因为我们用文法符号（终结符号/非终结符号）表示程序构造，所以将属性的概念从程序构造扩展到表示这些构造的文法符号上
- __翻译方案__（translation scheme）：一种将程序片段附加到一个文法的各个表达式上的表示法
  - 当在语法分析过程中使用一个产生式时，响应的程序片段就会执行
  - 程序片段的执行效果按照语法分析过程的顺序组合起来，得到的结果就是这次分析/综合处理源程序得到的翻译结果\
  *（说得太过晦涩难懂了，不过我猜就是EOPL（编程语言要领）中说的按照文法的规则、递归地处理）*

语法制导翻译方案将在本章多次使用
- 把中缀表达式翻译成后缀表达式
- 用于表达式求值，并用来构建一些程序构造的抽象语法树
- [第5章](ch5.md)将更详细地讨论语法制导表示法

## 后缀表示
本节的例子：中缀表达式到其后缀表示的翻译

一个表达式的 __后缀表示__（postfix notation）
1. 如果E是一个变量或常量，则E的后缀表示是E本身
2. 如果E是一个形如 $E_1\bold{op}E_2$的表达式，其中op是一个二目运算符，那么E的后缀表示是 $E'_1E'_2\bold{op}$，这里E'1和E'2分别是E1和E2的后缀表示
3. 如果E是一个形如 $(E_1)$ 的被括号括起来的表达式，则E的后缀表示就是E1的后缀表示

*（其实这个倒不用太纠结，只是具体实现之前可能需要列出来）*

例子：*略*

例子：*略*

## 综合属性
将量和程序关联起来（例如把数值/类型和表达式相关联）的想法可以基于文法表示
- 将属性和文法的非终结符号及终结符号相关联
- 给文法的各个产生式附加语义规则
- 对于语法分析树的一个结点，如果它和它的子结点之间的关系符合某个产生式，那么该产生式对应的规则就描述了如何计算这个结点上的属性

*（很扯，有必要这么晦涩吗？感觉是在说求值的过程，还是先求局部，后求整体）*

__语法制导定义__（syntax-directed definition）
1. 把每个文法符号和一个属性集合相关联
2. 把每个产生式和一组 __语义规则__（semantic rule）相关联，这些规则用于计算与该产生式中符号相关联的属性值

属性可以按照如下方式求值
- 对于给定的输入串x，构建x的一个语法分析树
- 按照下面的方法应用语义规则来计算语法分析树中各个结点的属性
  - 假设语法分析树的一个结点N的标号为文法符号X
  - 用X.a表示该结点上X的属性a的值
  - 如果一棵语法分析树的各个结点上标记了相应的属性值，那么这棵语法分析树就称为 __注解__（annotated）语法分析树（简称注解分析树）\
    *（原文把annotated翻译成“注释”（comment），感觉非常不利于理解）*

图中显示一棵注解分析树
- 9-5+2的一棵注解分析树
  ```
  expr.t = 95-2+
  ├─ expr.t = 95-
  │  ├─ expr.t = 9
  │  │  └─ term.t = 9
  │  │     └─ 9 ....... (9)
  │  ├─ - ............. (-)
  │  └─ term.t = 5
  │     └─ 5 .......... (5)
  ├─ + ................ (+)
  └─ term.t = 2
     └─ 2 ............. (2)
  （转绘过程中，原本的从左往右的叶子结点，现在变成从上往下）
  ```
- 属性t与非终结符号 `expr` 和 `term` 关联
- 该属性在根结点处的值为 `95-2+`，也就是 `9 - 5 + 2` 的后缀表示
- 我们很快会看到这些表达式的计算方法

*（所谓属性，看起来就是“求值结果”，或者是希望从语法分析树中得到的结果，例子中是从语法分析树中得到后缀表达式；这种方式表示的语法分析树的特点是容易验证，但似乎暂时并没有说明如何获得该树；除此以外，仍然表明了根节点的计算要依据子节点的计算结果）*

__综合属性__（synthesized attribute）
- 如果某个属性在语法分析树结点N上的值是由N的子节点以及N本身的属性值确定的\
  ~~*（你在开玩笑吗？“属性在结点N上的值”，一部分决定于“N本身的属性值”？自己决定自己？）*~~\
  *（可能翻译有问题，这里应该是指，结点N本身带有如何把子节点的结果“综合”起来的规则描述）*
- 那么这个属性就称为 __综合属性__

综合属性具有一个很好的性质：只需要对语法分析树进行一次自底向上的遍历，就可以计算出属性的值

预告：
- 在5.1.1节中，我们将讨论另外一种重要的属性：“继承”属性
- 通俗地讲，继承属性在某个语法分析树结点上的值是由语法分析树中该结点本身、父节点以及兄弟结点上的属性值决定的

*（明白了，这是在说明，并不是所有所谓“属性”都能够通过自底向上遍历树的方式，方便地计算。也就是说，只有“综合属性”才能这样做。所谓“综合”的含义应该是指，“取自后代，将结果进行综合”）*

例子：前面所说图中注解分析树是根据 __语法制导定义__ 得到的
- 定义
  |产生式|语义规则|
  |-|-|
  |`expr->expr1+term`|`expr.t=expr1.t\|\|term.t\|\|'+'`|
  |`expr->expr1-term`|`expr.t=expr1.t\|\|term.t\|\|'-'`|
  |`expr->term`|`expr.t=term.t`|
  |`term->0`|`term.t='0'`|
  |`term->1`|`term.t='1'`|
  |...|...|
  |`term->9`|`term.t='9'`|
- 该定义用于把一个表达式翻译为该表达式的后缀形式
- 待翻译的表达式是一个由加号和减号分隔的数位序列
- 图中每个非终结符号有一个值为字符串的属性t，表示由该非终结符号生成的表达式的后缀表示形式
- 语义规则中的符号 `||` 表示字符串的连接运算符
- 规则解释：*略*

<div style="border:1px solid;padding:10px">

**区分一个非终结符号的不同使用的规则**
- 在规则中，经常要区分一个非终结符号在产生式的头和/或体中的使用
- 原因是，语法分析树中，标号为同一非终结符号的不同结点通常在翻译中具有不同的属性值

我们将采用规则
- 出现在式头的非终结符号没有下标
- 在产生式体的非终结符号带有不同的下标
- 同一个非终结符号的所有出现都按照这种方式区分
- 下标不是名字的组成部分

</div>

## 简单语法制导定义
__简单__（simple）语法制导定义：
- 上面的例子中，要得到代表产生式头部的非终结符号翻译结果的字符串
- 只需要将产生式体中各非终结符号的翻译结果按照它们在非终结符号中的出现顺序连接起来
- 并在其中穿插一些附加串即可
- 具有这个性质的语法制导定义，称为简单语法制导定义

例子：*略*

当讨论翻译方案的时候，我们将看到，一个简单语法制导定义的实现很简单，只需要按照它们在定义中出现的顺序打印出附加的串即可

## 树的遍历
树的遍历将用于描述
- 属性的求值过程
- 一个翻译方案中各个代码片段的执行过程

树的遍历从根节点开始，按照某个顺序访问树的各个结点

__深度优先__（depth-first）遍历：
- 从根结点开始，递归地按照任意顺序访问各个结点的子结点
- 并不一定要按照从左到右的顺序遍历
- 这种遍历总是尽可能地访问一个结点尚未被访问的子节点，尽可能地访问离根结点最远的结点（最深的结点）

__语法制导定义__ 并没有规定一棵语法分析树的各个属性值的求值顺序
- 只要一个顺序能够保证计算属性a的值时，a所依赖的其他属性都已经计算完毕，这个顺序就是可以接受的
- __综合属性__ 可以在 __自底向上__ 遍历的时候计算
- 一般来说，当既有 __综合属性__ 又有 __继承属性__ 时，关于求值顺序的问题便能的相当复杂，参见5.2节

## 翻译方案
我们考虑另一种不需要操作字符串的方法（不同于之前翻译方案的例子），通过运行程序片段，逐步生成相应的翻译结果

<div style="border:1px solid;padding:10px">

**前序遍历和后序遍历**
- 是深度优先遍历的两种重要特例
- 这两种遍历中，我们都是从左到右递归地访问每个结点的子节点
- 遍历一棵树，并在各个结点上执行某些动作
  - __前序遍历__：动作在我们第一次访问同一个结点时被执行
  - __后序遍历__：动作在我们最后离开一个结点前被执行

前序遍历和后续遍历根据一个结点的动作执行时间来定义这些结点的相应次序
- 一棵以结点N为根的（子）树
- __前序排序__：由N，跟上它的从左到右每棵子树（如果存在）的前序排序组成
- __后序排序__：由N的从左到右的每棵子树的后续排序，再跟上N自身组成

*（我怀疑这里说的不是排序，而是扁平化）*

*（所谓前序后序，大概是指根结点处理的时机：前序：如果先处理根结点，后往下钻；后序：先往下钻，后处理根结点）*
</div>

__语法制导翻译方案__
- 是一种在文法产生式中附加一些程序片段来描述翻译结果的表示方法
- 与 __语法制导定义__ 相似，只是显式地制定了语义规则的计算顺序

__语义动作__（semantic action）
- 被嵌入到产生式体中的程序片段
- 一个语义动作用花括号括起来，并写入产生式的体中
- 它的执行位置也由此指定
- 例如：`rest -> + term {print('+')} rest1`
- 当我们考虑表达式的另一种形式的文法时，我们就会看到这样的规则
- 这种文法形式将在2.4.5节中讨论

当我们画出一个翻译方案的语法分析树时
- 我们为每个语义动作构造一个额外的子节点，使用虚线将它和该产生式头部对应的结点相连

*（__语法制导翻译方案__ 和 __语法制导定义__ 到底是什么关系？）*

例子：
- 语法分析树在额外的叶子结点含有打印语句
  ```
  expr
  ├─ expr
  │  ├─ expr
  │  │  └─ term
  │  │     ├─ 9 ....... (9)
  │  │     ╚═ {print('9')}
  │  ├─ - ............. (-)
  │  ├─ term
  │  ║  ├─ 5 .......... (5)
  │  ║  ╚═ {print('5')}
  │  ╚═ {print('-')}
  ├─ + ................ (+)
  ├─ term
  ║  ├─ 2 ............. (2)
  ║  ╚═ {print('2')}
  ╚═ {print('+')}
  （转绘过程中，原本的从左往右的叶子结点，现在变成从上往下）
  ```
  *（上面的print执行完之后，又变成希望翻译出来的后缀表达式了）*
- 根结点代表第一个产生式
- 根结点最左边的子树代表左边的运算分量，它的标点符号和根结点一样都是 `expr`
- 在一次后序遍历中
  - 首先执行该子树的所有语义动作
  - 然后访问没有语义动作的叶子节点 `+`
  - 接下来，执行代表右运算分量 `term` 的子树中的所有语义动作
  - 最后执行额外结点上的语义动作 `{print('+')}`
- 由于 `term` 的产生式的右部只有一个数位，该产生式的语义动作把这个数位打印出来
- 产生式 `expr->term` 不需要产生输出，只有前面两个产生式的语义动作中的运算符才会打印出来
- 语义动作会在分析树的后序遍历中执行时打印出`9 5 - 2 +`

介绍 __语法制导定义__ 使用到的树和介绍该 __语法制导翻译方案__ 时使用到的树，尽管产生结果相同，但构造过程不同
- 前者是把字符串作为属性附加到语法分析树的结点上
- 后者通过语义动作把翻译结果以增量的方式打印出来

实现一个翻译方案时，必须保证各个语义动作按照它们在语法分析树的后序遍历中的顺序执行
- 不一定真的要构造出一棵语法分析树（通常也不会）
- 只要能够确保语义动作的执行过程等同于我们真的构造了语法分析树，并在后序遍历中执行这些动作即可

*（为什么？ __翻译方案__ 一定要用/等同于后序遍历吗？）（我怀疑原因在于要获得后缀表达式的这个“目的”；这是因为，无论希望获得前缀表达式还是后缀表达式，都不影响源语言如何被扫描、解析，如何生成语法分析树，归根结底，“后缀表达式”这个结果，是在语义分析这一步出现的）*

*（如果我不希望打印出来，不希望有副作用，该怎么办呢？）*

## 2.3节的练习
*略*

# 语法分析
<i style="color:gray">对应扫描中文版pdf页码37</i>

__语法分析__
- 是决定如何使用一个文法生成一个终结符号串的过程\
  *（和我之前说得一样，有点逆向提问题的感觉，符号串是“输入”，被当作“结果”，而语法分析树是“输出”，也就是我们想知道的“过程”）*
- 尽管在实践中编译器并没有真的构造出这棵树，然而原则上语法分析器必须能够构造出语法分析树，否则将无法保证翻译的正确性

预告
- 本节介绍 __递归下降__：一种语法分析方法，该方法可用于语法分析和实现语法制导翻译器
- 下一节将给出一个实现了前述打印出 `"95-2+"` 字符串的翻译方案的完整Java程序；另一种可行方法是使用软件工具直接根据翻译方案生成一个翻译器
- 4.9 节将描述这样的一个工具 Yacc。使用这个工具，无需修改就可以实现前面说的翻译方案

效率
- 对于任何上下文无关文法，我们都可以构造出一个时间复杂度为 O(n^3) 的语法分析器
- 它最多使用 O(n^3) 的时间就可以完成一个长度为 n 的符号串的语法分析
- 但是，三次方的时间代码一般太昂贵了
- 对于实际程序设计语言而言，我们通常能够设计出一个被高效分析的文法\
  *（“通常能”，是说能不能高效分析，可能和设计的文法有关是吗？）*
- 线性时间复杂度的算法足以分析实践中出现的各种程序设计语言
- 程序设计语言的语法分析器几乎总是一次性地从左到右扫描输入，每次向前看一个终结符号，并在扫描时构造出分析树的各个部分

大多数语法分析方法都可以归入以下两类：
- __自顶向下__（top-down）
  - 构造过程从根结点开始，逐步向叶子结点方向进行
- __自底向上__（bottom-up）
  - 构造过程从叶子结点开始，逐步构造出根结点

比较
- __自顶向下__ 语法分析器之所以受欢迎，是使用这种方法可以较容易地手工构造出高效的语法分析器
- __自底向上__ 分析方法可以处理更多文法和翻译方法，所以直接从文法生成语法分析器的软件工具常常使用自底向上的方法

## 自顶向下分析法
本节后面的内容中，我们将考虑构造自顶向下语法分析器的一般方法

C或Java语句的一个子集
```
   stmt -> expr ;
         | if (expr) stmt
         | for (optexpr; optexpr; optexpr) stmt
         | other

optexpr -> ε
         | expr
```

自顶向下地构造一棵语法分析树，从标号开始为非终结符stmt的根结点开始，反复执行两个步骤
1. 在标号为非终结符号A的结点N上，选择A的一个产生式，为该产生式体中的各个符号构造出N的子结点
2. 寻找下一个结点来构造子树，通常选择的是有语法分析树最左边的尚未扩展的非终结符号

对于某些文法，上面的步骤只需要对输入串进行一次从左到右的扫描就可以完成
- 输入中当前被扫描的终结符号通常称为 __向前看__（lookahead）符号
- 开始时，向前看符号是输入串的第一个（最左的）终结符号

演示输入串 `for ( ; expr ; expr ) other` 的语法分析树的构造过程
- 一开始
  - 向前看符号是终结符号for
  - 语法分析树的已知部分只包含为开始非终结符号 `stmt` 的根结点
  - 目标是以适当的方法构造出语法分析树的其余部分，使得这棵树生成的符号串与输入符号串匹配
- 为了与输入串匹配，根结点非终结符号 `stmt` 必须推导出一个以向前看符号 `for` 开头的串
  - 在文法中，`stmt` 只有一个产生式可以推导出这样的串，所以选择这个产生式，并构造出根结点的各个子节点，并使用该产生式体中的符号作为这些子节点的标号
- 在（原pdf的）图中所示的三个快照（三个阶段），都包含
  - 一个指向输入串中向前看符号的箭头
  - 一个指向当前正被考虑的语法分析树结点的箭头
- 一旦一个结点的子节点全部构造完毕，我们就要考虑该结点的最左子节点
  - 如果当前正考虑的语法分析树结点的标号是一个终结符号，并且此终结符号与向前看符号匹配，那么语法分析树的箭头和输入箭头都前进一步
  - 输入中的下一个终结符称为新的向前看符号，同时考虑语法分析树的下一个子节点
- 在标号为 `optexpr` 的非终结符号结点上，我们需要再次为一个非终结符号选择产生式，以 ε 为体的产生式（称 ε 产生式）需要特别处理
  - 当前，我们将 ε 产生式当作默认选择，只有在没有其它产生式可用时才会选择它们
  - 我们将在[2.4.3节](ch2.md#何时使用-ε-产生式)中再次讨论 ε 产生式

一般来说，为一个非终结符号选择产生式是一个试错的过程
- 首先选择一个产生式
- 在这个产生式不合适时回溯，再尝试另一个产生式
- 一个产生式“不合适”是指使用了该产生式之后，我们无法构造得到一棵与当前输入串相匹配的语法分析树
- 但是在称为 __预测语法分析__ 的特殊情形下不需要进行回溯

*（haskell 的 parsec 库似乎在“解析”字符串的时候，就允许“回溯”了，也就是用 `<|>`）*

## 预测分析法
__递归下降分析方法__（recursive-descent parsing）是一种 __自顶向下__ 的语法分析方法
- 使用一组递归过程来处理输入
- 文法的每个非终结符都有一个相关联的过程

这里我们考虑递归下降分析法的一种简单形式，称为 __预测分析法__（predictive parsing）

预测分析法中
- 各个非终结符号对应的规程中的控制流可以由向前看符号无二义地确定
- 在分析输入串时出现的过程调用序列隐式地定义了该输入串的一棵语法分析树
- 如果需要，还可以通过这些过程调用来构建一个显式的语法分析树

预测分析器
``` Java
void stmt() {
  switch (lookahead) {
    case expr:
      match(expr); match(';');break;
    case if:
      match(if); match('(');match(expr);match(')');stmt();
      break;
    case for:
      match(for); match('(');
      optexpr(); match(';'); optexpr(); match(';'); optexpr();
      match(')'); stmt(); break;
    case other:
      match(other); break;
    default:
      report("syntax error");
  }
}
void optexpr() {
  if (lookahead == expr) match(expr);
}
void match(terminal t) {
  if (lookahead == t) lookahead = nextTerminal;
  else report("syntax error");
}
```
- 分析过程开始时，首先调用文法的开始非终结符号 `stmt` 对应的过程
- `lookahead` 被初始化为第一个终结符号 `for`
- 过程 `stmt` 执行和如下产生式对应的代码
  `stmt -> for (optexpr ; optexpr ; optexpr) stmt`
- 在对应于该产生式体的代码中—— `stmt` 中的case分支——
  - 每个终结符都和向前看符号匹配
  - 每个非终结符都产生一个对相应过程的调用

  *（明白了，我们让函数代表非终结符号，让 `match(*)` 代表终结符号）*

__预测分析__ 需要知道哪些符号可能成为一个产生式体所生成串的第一个符号
- 更准确地说，令 α 是一个文法符号（终结符号或非终结符号）串
- 我们将 FIRST(α) 定义为可以由 α 生成的一个或多个终结符号串的第一个符号的集合
- 如果 α 就是 ε 或者可以生成 ε，那么 ε 也在 FIRST(α) 中

*（看来，如果要实现 __预测分析__，就要知道 switch 分支/if 分支怎么写，也就对应了所生成的终结符号串的第一个符号）*

FIRST(α)
- 关于计算 FIRST(α) 的算法的详细描述将在 4.4.2 节中给出
- 这里，我们将使用不具一般性的推导方法求出 FIRST(α) 中的符号

推导
- 通常形况下，α 要么以一个终结符号开头，此时该终结符号就是 FIRST(α) 中的唯一符号
- 要么 α 以一个非终结符号开头，且该非终结符号的所有产生式体各自以某个终结符号开头，那么这些终结符号就是 FIRST(α) 的所有成员

例如，对于前面提到的文法，其 FIRST 的正确计算如下
> FIRST(_stmt_) = {**expr, if, for, other**}\
> FIRST(**expr ;** ) = {**expr**}

如果有两个产生式 `A->α` 和 `A->β`，我们就必须考虑相应的 FIRST 集合
- 如果我们不考虑 ε 产生式，预测分析法要求 FIRST(α) 和 FIRST(β) 不相交
- 那么就可以用向前看符号来确定应该使用哪种产生式
- 如果向前看符号在 FIRST(α) 中，就使用 α，如果向前看符号在 FIRST(β) 中，就使用 β

*（跟我在前面说得一样，要实现 __预测分析法__，就要知道switch/if分支怎么写，如果每个产生式的第一个符号都不一样，只要看第一个符号，就唯一地知道该使用哪个产生式了）*

## 何时使用 ε 产生式
预测分析器在没有其它产生式可用时，将 ε 产生式作为默认选择使用
- 前面的预测分析器程序中，非终结符号 `optexpr` 有两个产生式，体分别为 `expr` 和 `ε`
- 向前看符号 `;` 与终结符号 `expr` 不匹配，因此不能使用以 `expr` 为体的产生式
- 事实上，该过程没有改变向前看符号，不做任何操作就返回
- 这种不做任何操作就对应于应用 ε 产生式的情形

对于更一般化的情况
- 考虑前面说的 __文法__ 的一个变体，`optexpr` 生成一个表达式非终结符号，而不是终结符号 `expr`\
  ```
  optexpr -> expr
           | ε
  ```
- 这样，`optexpr` 要么使用非终结符号 `expr` 生成一个表达式，要么生成 ε
- 在对 `optexpr` 进行语法分析时，如果向前看符号不在 FIRST(expr) 中，我们就使用 ε 产生式

要更加深入地了解应该在何时使用 ε 产生式，请参见 4.4.3 节中关于 LL(1) 文法的讨论

## 设计一个预测分析器
可以将[ 2.4.2 节](ch2.md#预测分析法)中非正式介绍的技术推广应用到任意具有如下性质的文法上
- 对于文法的任何非终结符号，它的各个产生式体的 FIRST 集合互不相交
- 如果我们有一个 __翻译方案__，即，一个增加了 __语义动作__ 的 __文法__，那么我们可以将这些语义动作当作语法分析器的过程的一部分执行

一个 __预测分析器__ 程序由各个非终结符对应的过程组成，对应于非终结符 A 的过程完成以下两项任务
1. 检查向前看符号，决定使用 A 的哪个从产生式
    - 如果一个产生式的体为 α（不是空串 ε）且向前看符号在 FIRST(α) 中，就选择这个产生式
    - 对于任何向前看符号，如果两个非空的产生式体之间存在冲突，就不能对这种文法使用 __预测语法分析__
    - 如果 A 有 ε 产生式，那么只有当向前看符号不在 A 的其它产生式体的 FIRST 集合中时，才会使用 A 的 ε 产生式
2. 模拟被选中产生式的体
    - 从左边开始逐个“执行”此产生式体中的符号
    - “执行”一个非终结符号的方法是调用该非终结符号对应的过程
    - “执行”一个与向前看符号匹配的终结符号则是读入下一个输入符号
    - 如果在某个点上，产生式体中的终结符号和向前看符号不匹配，那么语法分析器就会报告一个语法错误

就像通过扩展 __文法__ 得到一个 __翻译方案__ 一样，我们也可以扩展一个 __预测分析器__ 来获得一个 __语法制导的翻译器__
- 在5.4节中将给出一个能够达到此目的的算法
- 下面的部分构造方法已经可以满足当前的要求
  1. 先不考虑产生式中的动作，构造一个 __预测分析器__
  2. 将 __翻译方案__ 中的动作拷贝到 __语法分析器__ 中
      - 如果一个动作出现在产生式 p 中的文法符号 X 的后面
      - 则该动作就被拷贝到 p 的代码中 X 的实现之后
      - 否则，如果该动作出现在一个产生式的开头，那么它就被拷贝到该产生式体的实现代码之前

*（__翻译方案__、__语义动作__ 和 __语法分析器__ 的关系到底是什么？）*

*（试着梳理一下关系，如下面的表格）*

| 概念 | 与文法的关系 | 与语法制导定义的关系 | 与语法分析器的关系 |
|---|---|---|---|
| 文法 | —— | 是语法制导定义和翻译方案的基础 | 是语法分析器的基础 |
| 语法制导定义 | 基于文法，将属性和语义规则附加到产生式上 | —— | 可用于指导语法分析器进行语义处理（如属性计算、生成代码等） |
| 翻译方案 | 在文法产生式中嵌入语义动作 | 是语法制导定义的具体实现方式 | 翻译方案可嵌入到语法分析器（如预测分析器）中，形成 __语法制导翻译器__ |
| 语法分析器 | 按照文法规则分析输入串，构建语法结构 | 可结合语法制导定义/翻译方案一起工作 | —— |
| 预测分析器 | 只能用于满足特定条件（如LL(1)）的文法 | 可嵌入翻译方案（语义动作）成为 __语法制导翻译器__ | 语法分析器的一种实现方式 |

我们将在[ 2.5 节](ch2.md#简单表达式的翻译器)构造这样一个翻译器

## 左递归
递归下降语法分析器有可能进入无限循环
- 当出现“左递归”产生式时，分析器就会出现无限循环 `expr -> expr -> term`
- 这里，产生式体的最左边的符号和产生式头部的非终结符相同
- 假设 `expr` 对应的过程决定使用这个产生式，因为产生式体开头是 `expr`，所以对应的过程将被递归调用
- 只有当产生式体中的一个终结符号被成功匹配时，向前看符号才会发生改变
- 结果，第二次 `expr` 调用所做的事情与第一次调用所做的完全相同，意味着会对 `expr` 进行第三次调用，并不断重复，进入无限循环

通过改写有问题的产生式就可以消除 __左递归__
- 有两个产生式 `A -> Aα | β` 的非终结符号 `A`，其中 α 和 β 是不以 A 开头的终结符号/非终结符号的序列
- 在产生式 `expr -> expr + term | term` 中
  - 非终结符号 `A=expr`
  - 串 `α = + term`
  - 串 `β = term`
- 因为产生式 `A -> Aα` 的右部的最左符号是 A 自身，非终结符号 A 和它的产生式就称为 __左递归的__（left recursive）\
  *作者注：在一般的左递归文法中，非终结符号A可能通过一些中间产生式推导出 `Aα`，而不一定存在产生式 `A -> Aα`*
- 不断应用这个产生式将在 A 的右边生成一个 α 的序列，当 A 最终被替换为 β 时，就得到了一个在 β 后跟有 0 个或多个 α 的序列

*（第一次可能没有注意到，上面说的其实应该是一种消除左递归的方法）*

__右递归__
- 非终结符号 R 和它的产生式 `R -> αR` 是 __右递归的__（right recursive），因为这个产生式的右部的最后一个符号就是 R 本身
- 右递归的产生式会使得树向右下方向生长
- 因为树是向右下生长的，对包括了左结合运算符（如减法）的翻译就变得较为困难
- 然而，我们将在[ 2.5.2 节](ch2.md#调整翻译方案)看到，通过仔细设计翻译方案，我们仍然可以将一个表达式正确地翻译成后缀表达式

*（为什么对包含左结合运算符的表达式的翻译会变得较为困难？可能是因为左结合运算符导致树向左下生长，可是，这又有什么关系呢？）*

*（似乎并没有说右递归会陷入无限循环，只是说会让翻译“较为困难”，所以右递归可能问题相对不大）*

在4.3.3节，我们将考虑更一般的左递归形式，并说明如何从文法中消除左递归

*（左递归应该是从文法中产生的，要消除左递归，难道要改变文法吗？）*

## 2.4节的练习
*略*

*（这个练习题的第2题确实很有意思，把非终结符看作一个过程，它一定会递归调用自己，然后就进入无限循环了，永远无法出来）*

# 简单表达式的翻译器
<i style="color:gray">对应扫描中文版pdf页码43</i>

使用前三节介绍的技术，我们可以用Java编写一个 __语法制导翻译器__\
*（看来，[第 2.2 节](ch2.md#语法定义)、[第 2.3 节](ch2.md#语法制导翻译)、[第 2.4 节](ch2.md#语法分析)综合的结果是 __语法制导翻译器__）*
- 这个翻译器可以把算数表达式翻译成等价的后缀形式
- 为了使最初的程序比较小且容易理解，我们首先处理最简单的表达式，由二目运算符加号和减号分隔的数位序列
- 在[ 2.6 节](ch2.md#词法分析)中，我们将拓展这个程序，使它能够翻译包含数字和其它运算符的表达式
- 由于表达式是很多程序设计语言中的构造，因此深入研究表达式的翻译问题是有意义的

__语法制导翻译方案__ 常常作为翻译器的规约

翻译方案定义了要执行的翻译过程
```
expr -> expr + term { print('+') }
      | expr - term { print('-') }
      | term
term -> 0           { print('0') }
      | 1           { print('1') }
        ...
      | 9           { print('9') }
```

在使用一个 __预测语法分析器__ 进行语法分析时，常常需要修改一个给定翻译方案的基础文法
- 特别地，刚刚提到的翻译方案是 __左递归的__
- 如上一节所述，__预测语法分析器__ 不能处理左递归的文法

矛盾
- 一方面，需要一个能够支持翻译规约的文法
- 另一方面，需要一个明显不同的能够支持分析过程的文法

解决方法
- 首先使用易于翻译的文法
- 然后再小心地对这个文法进行转换，使之能否支持语法分析

通过消除左递归，我们可以得到一个适用于 __预测递归下降翻译器__ 的文法

## 抽象语法和具体语法
__抽象语法树__（abstract syntax tree）
- 设计一个翻译器时，名为抽象语法树的数据结构是一个很好的起点
- 在一个表达式的抽象语法树中，每个内部结点代表一个运算符，该结点的子节点代表这个运算符的运算分量\
  *（终于！现在才出现AST，也就是lisp族语言的代码所类似的形式）*
- 对于更加一般化的情况，当我们处理任意的程序设计语言构造时
  - 可以创建一个针对这个构造的运算符
  - 并把这个构造的具有语义信息的组成部分作为这个运算符的运算分量

`9 - 5 + 2` 的抽象语法树
```
  +
  ├─ -
  │  ├─ 9
  │  └─ 5
  └─ 2
  （转绘过程中，原本的从左往右的叶子结点，现在变成从上往下）
```
- 根结点代表运算符 `+`
- 根结点的子树分别代表子表达式 `9 - 5` 和 2
- 将 `9 - 5` 组成一个运算分量反映了在对优先级相同的运算符求值时，求值顺序总是从左到右的

__抽象语法树__ 也简称 __语法树__（syntax tree），在某种程度上和 __语法分析树__ 相似
- 在抽象语法树中，内部结点代表的是程序构造
- 在语法分析树中，内部结点代表的是非终结符号
- 辅助符号
  - 文法中的很多非终结符号都代表程序的构造，但也有一部分是各种辅助符号，如代表项、因子或其它表达式变体的非终结符号
  - 抽象语法树中，通常不需要这些辅助符号，因此会将这些符号省略掉
- 为了强调它们之间的区别，我们有时会把 __语法分析树__ 称为 __具体语法树__（concrete syntax tree），相对应的文法称为 __具体语法__（concrete syntax）

*（haskell的parsec库似乎通过解析器组合的方式规避了许多问题，直接能得到抽象语法树。实际上，解析器组合器（parser combinator）和解析器生成器（parser generator）是不同的两支，前者通常更慢，但据说表达力更强）*

## 调整翻译方案
前面（[第 2.4.5 节](ch2.md#左递归)）简述的左递归消除技术，同样可以应用于包含了语义动作的产生式
- 该技术被拓展到 A 的多个产生式中
- 我们的例子中 A 就是 `expr`，它有两个 `expr` 的左递归产生式和一个非左递归的产生式
- 这个技术将产生式 `A -> Aα | Aβ | γ` 转换成
  ```
  A -> γR
  R -> αR | βR | ε
  ```
  *（R是一种自身递归的结构，如果用正则表达式来写可能更加直观：`[αβ]*`。根据前面说的消除左递归的技术，A最终的结果是 γ （开头为终结符的生成式）跟着0个或多个“α 或 β”（开头为非终结符的生成式中，后续跟随的符号））*
- 其次，我们要转换的产生式不仅包含终结符号和非终结符号，还包括内嵌动作
- 嵌入在产生式中的语义动作在转换时被当作终结符号直接复制\
  *（这就解释得通了，为什么要在文法的产生式里面嵌入语义动作，变成 __翻译方案__）*

例子
- 考虑前面说的翻译方案，令
  ```
  A = expr
  α = + term { print('+') }
  β = - term { print('-') }
  γ = term
  ```
- 进行左递归消除转换后将产生翻译方案
  ```
  expr -> term rest
  rest -> + term {print('+')} rest
        | - term {print('-')} rest
        | ε
  term -> 0 {print('0')}
        | 1 {print('1')}
          ...
        | 9 {print('9')}
  ```
- 对 `9 - 5 + 2` 进行的翻译过程
  ```
  expr
  ├─ term
  │  └─ 9 ................ (9)
  │     ╚═ {print('9')}
  ├─ rest
  │  ├─ - ................ (-)
  │  ├─ term
  │  ║  ├─ 5 ............. (5)
  │  ║  ╚═ {print('5')}
  │  ╚═ {print('-')}
  └─ rest
     ├─ + ................ (+)
     ├─ term
     │  ├─ 2 ............. (2)
     │  ╚═ {print('2')}
     ╠═ {print('+')}
     └─ rest
        └─ ε
  （转绘过程中，原本的从左往右的叶子结点，现在变成从上往下）
  ```

左递归消除的工作必须小心进行，以确保消除后的结果保持语义动作的顺序
- 例如，在消除左递归后的翻译方案中，动作 `{print('+')}` 和 `{print('-')}` 都处于产生式体的中间，两边分别是非终结符号 `term` 和 `rest`
- 假如这个动作放到产生式的末尾，即 `rest` 之后，那么这个翻译就是不正确的

## 非终结符号的过程
函数 `expr`、`term`、`rest` 实现了消除左递归后的 __语法制导翻译方案__
``` Java
void expr() {
  term(); rest();
}

void rest() {
  if (lookahead == '+') {
    match('+'); temr(); print('+'); rest();
  } else if (lookahead == '-') {
    match('-'); term(); print('-'); rest();
  }
}

void term() {
  if (lookahead 是一个数位) {
    t = lookahead; match(lookahead); print(t);
  } else report("语法错误");
}
```
- 这些函数模拟了对应于非终结符号的各个产生式体
- 解释：*略*
- *作者注：作为一个小小的优化，在 term() 中调用 match 之前可以打印这个数位，避免将这个数位保存起来。一般来说，改变语义动作和文法符号之间的顺序是有风险的，因为这么做可能改变这个翻译的结果*

## 翻译器的简化
我们对前面给出的代码做两处简化
- 我们将把过程 `rest` 展开到过程 `expr` 中
- 这样的简化处理可以减少需要使用的过程数目

简化
1. 某些递归调用可以替换为迭代
    - 如果一个过程体中执行的最后一条语句是对该过程的递归调用，那么这个调用就称 __尾递归的__（tail recursive）
    - 对于没有参数的过程，一个尾递归调用可以替换为跳转到过程开头的语句
    - 过程 `rest` 的代码改写为
      ``` Java
      void rest() {
        while (true) {
          if (lookahead == '+') {
            match('+'); term(); print('+'); continue;
          } else if (lookahead == '-') {
            match('-'); term(); print('-'); continue;
          }
          break;
        }
      }
      ```
2. 一旦 `rest` 过程的尾递归调用被替换为迭代过程，`rest` 的调用仅仅出现在过程 `expr` 中，因此可以内联化，将这两个函数合二为一

## 完整的程序
*略*

# 词法分析
<i style="color:gray">对应扫描中文版pdf页码47</i>

词法分析器从输入中读取字符，并将它们组成“词法单元对象”
- 除了用于语法分析的终结符号之外，一些 __词法单元对象__ 还包括一些附加信息，这些信息以属性值的形式出现
- 至今为止，我们还不需要区分术语“词法单元”和“终结符号”，因为词法分析器忽略了词法单元中带有的属性值
- 在本节中，一个词法单元就是一个带有附加信息的终结符号

__词素__
- 构成一个词法单元的输入字符序列
- 我们可以说，词法分析器使得语法分析不需要考虑词法单元的词素表示方式

本节的词法分析器允许在表达式中出现数字、标识符和“空白”（空格、制表符、换行符）
- 用于扩展上一节介绍的 __表达式翻译器__
- 要允许在表达式中出现数字和标识符，就必须扩展表达式文法
- 借此机会进一步支持乘法和除法
- 扩展后
  ```
    expr -> expr + term { print('+') }
          | expr - term { print('+') }
          | term
    term -> term * factor {print('*')}
          | term / factor {print('/')}
          | factor
  factor -> (expr)
          | num         { print(num.value) }
          | id          { print(id.lexeme) }
  ```
- 假定终结符号具有属性 `num.value`，该属性给出了对应于 num 的本次出现的整数值
- 终结符号 id 有一个值为字符串类型的属性，写作 `id.lexeme`，我们假设这个字符串就是这个 `id` 实例的实际词素

- 本节中介绍的方法适合于手写的 __词法分析器__
- 3.5 节描述了一个可根据一个词法规范生成词法分析器的工具Lex
- [2.7 节](ch2.md#符号表)讨论用于保存标识符相关信息的符号表或数据结构

## 剔除空白和注释
空格与注释
- [2.5 节](ch2.md#简单表达式的翻译器)的表达式翻译器读取输入中的每个字符，任何无关字符，如空格，都会使它运行失败
- 大部分语言允许词法单元之间出现任意数量的空白
- 语法分析过程中同样会忽略源程序中的注释

如果词法分析器消除了空白，那么语法分析器就不必再考虑它们
- 也可以修改文法，使得语法中包含空白，但这个方法很难

伪代码在遇到空格、制表符或换行符时不断读取输入字符，从而跳过了空白部分
``` C
for (;; peek = next input character) {
  if (peek 是空白或者制表符) 做某事;
  else if (peek 是换行) line = line+1;
  else break;
}
```
- 变量 `peak` 存放了下一个输入字符
- 在错误消息中假如行号和上下文有助于定位错误
- 这个代码使用变量 `line` 统计输入中的换行符个数

## 预读
预读
- 在决定向 __语法分析器__ 返回哪个词法单元之前，__词法分析器__ 可能需要预先读入一些字符
- 例子：`>` 和 `>=`

缓冲区
- 一个通用的预先读取输入的方式是使用输入缓冲区
- 词法分析器可以从缓冲区读取一个字符，也可以把字符放回缓冲区
- 对效率也是有意义的
- 我们可以用一个指针跟踪一被分析的输入部分，向缓冲区放回一个字符可以通过回移指针实现
- 输入缓冲技术在 3.2 节中讨论

仅预读一个字符
- 因为通常只需预读一个字符，所以也可以使用一个变量 `peek`，保存下一个输入字符
- 在读入一个数字的数位或一个标识符的字符时，本节的词法分析器会预读一个字符
- 例如，在 1 后面预读一个字符区分 1 和 10，在 `t` 后预读一个字符区分 `t` 和 `true`

只在必要时预读
- 例如 `*` 不需要预读就能识别，这种情况，`peek` 值被设置为空白符
- 词法分析器在寻找下一个词法单元时会掉过这个空白符
- 本节词法分析器一定满足的条件
  - 当词法分析器返回一个词法单元，变量 `peek` 要么保存了当前词法单元的词素后的那个字符
  - 要么保存空白符

## 常量
在一个表达式的文法中，任何允许出现数位的地方都应该允许任意的整形常量
- 我们可以创建一个代表整型常量的终结符号，如 `num`
- 也可以将整形常量的语法加入到文法中
- 将字符组成整数并计算它的数值的工作通常是由词法分析器完成的
- 在语法分析和翻译过程中可以将一个数字当作一个单元进行处理

当输入流中出现一个数位序列时，词法分析器将向语法分析器传送一个词法单元
- 该词法单元包含终结符号 `num`，及计算得到的整形属性值
- 如果把词法单元携程用 `<>` 括起来的元组，`31 + 28 + 59` 就转换成\
  `<num, 31> <+> <num, 28> <+> <num, 39>`
- 这里终结符号 `<+>` 没有属性

*（真正的常量应该不限于整形常量，应该还包括浮点数、字符串、布尔常量、枚举常量等等）*

## 识别关键字和标识符
__关键字__（keyword）
- 大多数程序设计语言使用 `for`、`do`、`if` 这样的固定字符串作为标点，或者标识某种构造

__标识符__
- 字符串还可以作为 __标识符__，为变量、数组、函数等命名
- 为了简化语法分析器，语言的文法通常把标识符当终结符号处理
- 当标识符出现在输入中时，语法分析器都会得到相同的终结符号，如 `id`
- 例如输入 `count = count + increment;`
  - 终结符号序列是 `id = id + id`
  - 将词法单元写作元组形式，看到输入流的元组序列 `<id, "count"> <=> <id, "count"> <+> <id, "increment"> <;>`

区分 __关键字__ 和 __标识符__
- 关键字通常也满足标识符组成规则
- 需要某种机制确定一个词素什么时候组成关键字，什么时候组成标识符
- 将关键字作为 __保留字__，使其不能用作标识符，这个问题相对容易解决
- 当一个字符串不是关键字时它才能组成一个标识符

本节词法分析器使用一个表保存字符串，解决两个问题
1. __单一表示__
    - 一个 __字符串表__ 可以将编译器的其余部分和表中字符串的具体表示隔开
    - 编译器后面的步骤可以只使用指向表中字符串的指针或引用
    - 操作引用要比操作字符本身更加高效\
      *（EOPL（编程语言要领）里面似乎说过用地址替代具体变量名的办法）*
2. __保留字__
    - 在初始化时在字符串表中加入保留的字符串以及它们对应的词法单元
    - 当词法分析器读到一个可以组成标识符的字符串或词素时，首先检查这个字符串表是否有这个词素
    - 如果有，它就返回表中的词法单元，否则返回带有终结符号 `id` 的词法单元\
      *（Javascript 似乎没有禁止使用部分关键字作为变量名，所以这种字符串表的方法也不尽然是通用的）*

在 Java 中，使用类 Hashtable 可以将一个字符串表实现为一张散列表
- `Hashtable words = new Hashtable();`
- 使用 `get` 操作查找保留字
  ``` Java
  if (peek 存放了一个字母) {
    将字母或数位读入一个缓冲区;
    s = b 中的字符形成的字符串;
    w = words.get(s) 返回的词法单元;
    if (w 不是 null) return w;
    else {
      将-键值对 (s, <id, s>) 加入到 words;
      return 词法单元<id, s>;
    }
  }
  ```
- 这里 `s` 可能是一个关键字，在表 `words` 初始化的时候这个 `s` 就已经在表中了
- 它也可能是一个之前被加入到表中的标识符
- 如果不存在 `s` 对应的条目，那么由 `id` 和属性值 `s` 组成的词法单元将被加入到字符串表中，并被返回

## 词法分析器
将本节到目前为止给出的伪代码片段组合起来，可以得到一个返回词法单元对象的函数 `scan`

*略，因为我不会Java*

## 2.6节的练习
*略*

# 符号表
<i style="color:gray">对应扫描中文版pdf页码53</i>

__符号表__
- 一种供编译器用于保存有关源程序构造的各种信息的数据结构
- 这些信息在 __分析阶段__（前端）被逐步收集放入符号表
- 在 __综合阶段__（后端）用于生成目标代码
- 符号表的每个条目中包含与一个 __标识符__ 相关的信息
  - 字符串（词素）
  - 类型
  - 存储位置
  - 其它相关信息
- 符号表通常需要支持同一标识符在一个程序中的多重声明

从 [1.6.1 节](ch1.md#静态和动态的区别)的内容可知
- 一个声明的作用域是指该声明起作用的那部分程序
- 我们将为每个作用域建立一个单独的符号表来实现作用域\
  *（在EOPL（编程语言要领）中，实现作用域使用的是 Env 模型）*
- 每个带有声明的程序块都会有自己的符号表，这个块中的每个声明都在此符号表中有一个对应条目
- 这种方法对其它能够设计作用域的程序设计语言同样有效
- 例如：类也可以用于自己的符号表

本节包括一个符号表模块，可以和本章的 Java 翻译器代码片段一起使用

为了简化，本节的主要例子是一个简化的语言
- 只包含与符号表相关的关键构造
- 比如：块、声明、因子等
- 所有其它的语句和表达式构造都被忽略了
- 使得我们可以关注符号表的操作
- 一个程序由多个块组成，每个块包含可选的声明和由单个标识符组成的语句
- 每个这样的语句都表示对相应标识符的一次使用
- [1.6.3 节](ch1.md#静态作用域和块结构)中块结构的例子处理了名字的定义和使用
- 简化版语言只由名字的定义和使用组成
  ``` C
  {int x; char y; {bool y; x; y; } x; y; }
  ```
- 目标：打印出一个修改过的程序，声明部分被删除，每个“语句”中的标识符之后都跟着一个冒号和该标识符的类型

<div style="border:1px solid;padding:10px">

**谁来创建符号表条目？**
- 在 __分析阶段__ 由词法分析器、语法分析器和语义分析器创建并使用
- 本章中，我们让语法分析创建条目
- 因为语法分析器知道一个程序的语法结构，相对于词法分析器而言，语法分析器通常更适合创建条目
- 它可以更好地区分一个标识符的不同声明

有些情况下
- 词法分析器可以在它碰到组成一个词素的字符串时立刻建立一个符号表条目

更多情况下
- 词法分析器只能向语法分析器返回一个词法单元，如 `id`，以及指向这个词素的指针
- 只有语法分析器才能决定是否使用之前已创建的符号表条目，还是为这个标识符创建一个新条目

*（也就是说，前面说的词法分析阶段一种可能存在的 __字符串表__，和这里的 __符号表__ 并不是同一回事）*

</div>

例子
- 处理前面给出的输入
  ``` C
  {int x; char y; {bool y; x; y; } x; y; }
  ```
- 目标是生成
  ```
  { { x:int; y:bool; } x:int; y:char; }
  ```
- 解释：*略*

## 为每个作用域设置一个符号表

## 符号表的使用

# 生成中间代码
<i style="color:gray">对应扫描中文版pdf页码57</i>

# 第2章总结
<i style="color:gray">对应扫描中文版pdf页码66</i>


[代目录](ReadMe.md#代目录)