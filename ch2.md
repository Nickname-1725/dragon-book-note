[代目录](ReadMe.md#代目录)

本章内容
- 对本书[第3章]至[第6章]中介绍编译技术的总体介绍
- 通过开发一个可运行Java程序演示这些编译技术
- 可以将具有代表性的程序设计语言翻译为三地址代码
- 重点是编译器的前端，特别是词法分析/语法分析/中间代码生成
- [第7章]和[第8章]将介绍如何根据三地址代码生成机器指令
- 从小事做起，建立一个将中级算数表达式转换为后缀表达式的语法制导翻译器
- 扩展这个翻译器，使它能够将某些程序片段转换为三地址代码

# 引言
<i style="color:gray">对应扫描中文版pdf页码24</i>

__语法__
- 分析阶段的工作是围绕“语法”展开的
- 一个程序式设计语言的 __语法__ （syntax）描述了该语言程序的正确形式
- __语义__（semantics）定义了程序的含义

__上下文无关文法__ 或 __BNF__（backus-naur范式）
- 描述语法的一个广泛使用的表示方法
- 不仅可以描述一个语言的语法，还可以指导程序翻译的过程\
  *（在EOPL（编程语言要领）里面也是这样的）*
- 在2.3节中，我们将介绍一种面向文法的翻译技术，__语法制导翻译__（syntax-directed translation）\
  *（应该是翻译的问题，应该翻译成语法导向翻译）*
- 语法扫描，或者语法分析，将在2.4节中介绍

使用现有语义表示方法来描述一个语言的语义难度远远大于描述语言语法的难度

本章其余部分快速浏览编译器前端模型
- 首先介绍语法分析器
- 首先考虑从中缀表达式到后缀表达式的语法制导翻译过程
- 将表达式翻译为后缀形式的过程可以充分演示语法分析技术，同时这个翻译过程又很简单
- 我们将在第2.5节中给出翻译器的全部程序

__标识符__
- 语法分析器使得翻译器可以处理由多个字符组成的构造，比如标识符
- 标识符由多个字符组成，但是在语法分析阶段被当作一个单元，这样的单元称作 __词法单元__（token）

中间代码生成
- 抽象语法树：表示了源程序的层次化语法结构；
- 语法分析器生成一棵语法树，它又被进一步翻译为三地址代码
- 有些编译器会将语法分析和中间代码生成合并为一个组件

# 语法定义
<i style="color:gray">对应扫描中文版pdf页码25</i>

- 这一节将介绍描述程序设计语法的表示方法：__上下文无关文法__
- 本书中，文法将被用于组织编译器前端

文法
- 自然地描述了大多数程序设计构造的层次化语法结构
- `if (expression) statement else statement`
  - 用 `expr` 表示表达式，用变量 `stmt` 表示语句
  - `stmt -> if (expr) stmt else stmt`
  - 其中的箭头可以读作“可以具有如下形式”
- 这样的规则称为 __产生式__（production）
- 一个产生式中，关键字 `if` 和括号这样的词法元素称为 __终结符号__（terminal）
- 像 `expr` 和 `stmt` 这样的变量，称为 __非终结符号__（nonterminal）\
  *（尚可继续代换的即“非终结”，无法再代换的即“终结”）*

## 文法定义
__上下文无关文法__ 的组成四元素
1. 终结符号集合，有时也称“词法单元”，是该文法所定义的语言的基本符号的集合
2. 非终结符号集合，有时也称“语法变量”。每个非终结符号表示一个终结符号的集合
3. 一个产生式集合
    - 包括
      - 一个 __产生式头部__ 或 者 __左部__ 的非终结符号
      - 一个箭头
      - 一个 __产生式体__ 或 __右部__ 的由终结符号及非终结符号组成的序列
    - 产生式主要用来表示某个构造的某种书写方式\
      *（既然是书写方式，是不是说要遵循源语言书写的习惯？）*
4. 指定一个非终结符号为 __开始符号__

<div style="border:1px solid;padding:10px">

**词法单元和终结符号**

编译器中，词法分析器
- 读入源程序的字符序列
- 组织为具有词法含义的词素
- 输出代表词素的词法单元序列

词法单元组成
1. 名字：
    - 语法分析器进行语法分析使用的抽象符号
    - 常常称为 __终结符号__
2. 属性值：
    - 如果词法单元具有属性值，囊二这个值就是指向符号表的指针
    - 符号表包含了该词法单元的附加信息，通常不是文法的组成部分
    - 我们在讨论语法分析时，通常将词法单元和终结符号当作同义词

</div>

描述文法时
- 我们会列出文法的产生式
- 首先列出开始符号对应的产生式
- 为表示方便，以同一个终结符号为头部的多个产生式的体可以放在一起表示，不同体之间用符号 `|`（读作“或”）分隔

描述文法的习惯（续）
- 如果某个非终结符号是某个产生式的头部，我们说该产生式是该非终结符号的产生式
- 零个终结符号组成的串称为 __空串__（empty string），记为 $\epsilon$

## 推导
根据文法推导符号时
- 从开始符号出发，不断将某个非终结符号替换为该非终结符号的某个产生式的体
- 可以从开始符号推导得到所有终结符号串的集合，称为该文法定义的 __语言__

*（从一般到特殊，从文法的规则，推导出具体的一串符号序列；所有凡是可能的序列，统称为语言）*

__语法分析__ 的任务
- 接受一个终结符号串作为输入，找出从文法开始符号推导出这个串的方法
- 如果不能从文法的开始符号推导得到该终结符号串，则报告该终结符号串中包含的语法错误

*（有点逆向求解问题的感觉）*

预告
- 主要语法分析方法将在第4章中讨论
- 本章中，为简单起见，首先处理像 `9 - 5 + 2` 这样的源程序，其中每个字符均为一个终结符号\
  *（其实，语法分析这个步骤，它真正的输入应该是“符号流”，也就是词法分析的输出，而不是真正的字符串；前面文法里面的“终结/非终结符号”，应该都属于“符号流”）*
- 一般情况下，一个源程序会包含由多个字符组成的词素，这些词素由词法分析器组成词法单元，而词法单元的第一个分量就是被语法分析器处理的终结符号

## 语法分析树
语法分析树
- 用图形的方式展现了从文法的开始符号推导出响应语言中符号串的过程

正式地讲，给定一个上下文无关文法，该文法的一颗语法分析树具有以下性质
1. 根节点的符号为文法的开始符号
2. 每个叶子结点的标号为一个终结符号或 $\epsilon$
3. 每个内部结点的标号为一个非终结符号
4. 如果非终结符号A是某个内部结点的标号，并且它的子结点标号从左到右分别为 $X_1,X_2,\cdots,X_n$
    - 那么必然存在产生式 $A\rightarrow X_1X_2\cdots,X_n$ 其中 $X_1,X_2,\cdots,X_n$ 既可以是终结符号，又可以是非终结符号
    - 作为一种特殊情况，如果 $A\rightarrow\epsilon$ 是一个产生式，那么一个标号为A的结点可以只有一个标号为 $\epsilon$ 的子结点

<div style="border:1px solid;padding:10px">

**关于树形结构的术语**
- 一棵树由 __结点__（node） 组成
  - 结点可以带有标号（label）
  - 本书中标号通常是文法符号
  - 当我们画一棵树时，常常只用这些标号代表相应的结点
- 树有且仅有一个根（root）结点……

*略*

</div>

一颗语法分析树的叶子结点从左向右构成了树的 __结果__（yield）
- 也就是从这棵语法分析树的根结点上的非终结符号推导得到的符号串
- 任何树的叶子结点都有一个自然的从左到右的顺序

__语法分析__
- 一个文法的语言的另一个定义：任何能够从某棵语法分析树生成的符号串的集合
- 为一个给定的终结符号串构建一棵语法分析树的过程称为对符号串进行 __语法分析__

## 二义性
二义性
- 一个文法可能有多棵语法分析树能够生成同一个给定的终结符号串
- 这样的文法称为具有 __二义性__（ambiguous）
- 要证明一个文法具有二义性，我们只需要找到一个终结符号串，说明它是两棵以上语法分析树的结果
- 对策
  - 需要为编译应用设计出没有二义性的文法
  - 或者在使用二义性文法时使用附加的规则消除二义性

## 运算符的结合性
结合性
- 当一个运算分量的左右两侧都有运算符时，我们需要一些规则来决定哪个运算符被应用于该运算分量
- __左结合__（associate）：当一个运算分量左右都有 `+`，它属于其左边的运算符
- 大多数程序设计语言中，加、减、乘、除四种运算符都是左结合的\
  *（左、右结合性影响的是，在一串同等优先级的运算符之间加括号，应该优先在左边积累括号）*\
  *（左右结合性和运算符对应的函数入口参数与运算符左右分量的对应位置之间无关）*
- 某些常用运算符是右结合的
  - 指数运算
  - C语言中的赋值运算符“=”及其后裔
- 带有右结合的串，比如 `a = b = c`，可以由如下文法产生：
  ```
  right -> letter = right | letter
  letter -> a | b | ... | z
  ```
- 左结合运算符的语法分析树向左下端延伸，右结合运算符的语法分析树向右下端延伸

## 运算符的优先级
举例
- 考虑表达式 `9 + 5 * 2`。该表达式有两种可能的解释，即 `(9 + 5) * 2` 或 `9 + (5 * 2)`
- `+` 和 `*` 的结合性规则只能作用于同一运算符的多次出现，因此它们无法解决这个二义性
- 当多种运算符出现时，我们需要给出一些规则定义运算符的相对优先关系\
  *（能否说运算符优先级的出现是为了解决一部分二义性？）*
- 如果 `*` 优先于 `+` 获得运算分量，就说 `*` 比 `+` 具有 __更高的优先级__

举例：
- 算数表达式的文法可以根据表示运算符结合性和优先级的表格来构建\
  *（haskell的parsec库似乎包含了这种表格的表达方式，能够处理文法）*\
  *（优先级表应该就是上面说的消除二义性的附加规则）*
- 考虑四个常用运算符和一个优先级表
- 创建两个非终结符号 `expr` 和 `term`，分别对应于这两个优先级层次
- 使用另一个非终结符号 `factor` 生成表达式中的基本单元
  - 当前表达式的基本单元是数位和带括号的表达式
  - `factor -> digit | (expr)`
- 考虑具有最高优先级的 `*` 和 `/`，由于运算符是左结合的，因此产生式和左结合列表产生式类似
  - ```
    term -> term * factor
          | term / factor
          | factor
    ```
- 类似地，`expr` 生成由加减运算符分隔的 `term` 列表
  - ```
    expr -> expr + term
          | expr - term
          | term
    ```
- 最终得到的文法是：*略*

<div style="border:1px,solid;padding:10px">

**上面举例中表达式文法的推广**
- 将 __因子__（factor）理解成不能被任何运算符分开的表达式
  - “不能分开”是指在任意因子的任意一边放置一个运算符，都不会导致这个因子的任何部分分离出来，成为这个运算符的分量
  - 因子本身作为一个整体可以成为该运算符的一个运算分量
  - 如果这个因子是一个由括号括起来的表达式，那么括号将起到保护其不被分开的作用
- 不是因子的 __项__（term）
  - 一个可能被高优先级的运算符分开，但不能被低优先级运算符分开的表达式
  - 一个不是因子或项的表达式可能被任何一个运算符分开
- 推广到具有n层优先级的情况，需要n+1个非终结符号
  - 通常，这个非终结符号的产生提只能是单个运算分量或括号括起来的表达式\
    *这句话应该是表示相对“不可分割”的特点*
  - 对于每个优先级都有一个非终结符号，表示能被该优先级或更高优先级的运算符分开的表达式
  - 通常，这个非终结符号的产生式
    - 有一些产生式体表示了该优先级的运算符的应用
    - 另有一个产生式体只包含了代表更高一层优先级的非终结符号\
    *（`factor` 也可以当作 `term` 的一种情况，更高优先级的一层也可以当作更低优先级的层次来用）*
</div>

举例：*略*

## 2.2节的练习
*略*

*（练习2.2.6为罗马数字构建一个上下文无关文法似乎很有意思）*

# 语法制导翻译
<i style="color:gray">对应扫描中文版pdf页码32</i>

语法制导翻译：通过向一个文法的产生式附加一些规则或程序片段得到
- 考虑一个由如下产生式生成的表达式 `expr`\
  `expr -> expr1 + term`
- `expr` 是两个子表达式 `expr1` 和 `term` 的和（`expr1` 中的下标只是表示区分）
- 利用 `expr` 的结构，用如下伪代码翻译 `expr`\
  ```
  翻译 expr1;
  翻译 term;
  处理 +;
  ```
- 我们将在[2.8节](ch2.md#生成中间代码)中使用这段伪代码的一个变体，为 `expr` 构造一颗语法分析树
  - 首先建立 `expr1` 和 `term` 的语法分析树
  - 然后处理 `+` 运算符并构造得到一个和此运算符对应的结点
- 为方便起见，本节的例子是从中缀表达式得到后缀表达式的翻译

本节介绍两个与语法制导翻译相关的概念：
- __属性__（attribute）：表示与某个程序构造相关的任意量
  - 属性可以是多种多样的：数据类型、生成代码中的指令数目、为某个构造生成的代码中第一条指令的位置
  - 因为我们用文法符号（终结符号/非终结符号）表示程序构造，所以将属性的概念从程序构造扩展到表示这些构造的文法符号上
- __翻译方案__（translation scheme）：一种将程序片段附加到一个文法的各个表达式上的表示法
  - 当在语法分析过程中使用一个产生式时，响应的程序片段就会执行
  - 程序片段的执行效果按照语法分析过程的顺序组合起来，得到的结果就是这次分析/综合处理源程序得到的翻译结果\
  *（说得太过晦涩难懂了，不过我猜就是EOPL（编程语言要领）中说的按照文法的规则、递归地处理）*

语法制导翻译方案将在本章多次使用
- 把中缀表达式翻译成后缀表达式
- 用于表达式求值，并用来构建一些程序构造的抽象语法树
- [第5章](ch5.md)将更详细地讨论语法制导表示法

## 后缀表示
本节的例子：中缀表达式到其后缀表示的翻译

一个表达式的 __后缀表示__（postfix notation）
1. 如果E是一个变量或常量，则E的后缀表示是E本身
2. 如果E是一个形如 $E_1\bold{op}E_2$的表达式，其中op是一个二目运算符，那么E的后缀表示是 $E'_1E'_2\bold{op}$，这里E'1和E'2分别是E1和E2的后缀表示
3. 如果E是一个形如 $(E_1)$ 的被括号括起来的表达式，则E的后缀表示就是E1的后缀表示

*（其实这个倒不用太纠结，只是具体实现之前可能需要列出来）*

例子：*略*

例子：*略*

## 综合属性
将量和程序关联起来（例如把数值/类型和表达式相关联）的想法可以基于文法表示
- 将属性和文法的非终结符号及终结符号相关联
- 给文法的各个产生式附加语义规则
- 对于语法分析树的一个结点，如果它和它的子结点之间的关系符合某个产生式，那么该产生式对应的规则就描述了如何计算这个结点上的属性

*（很扯，有必要这么晦涩吗？感觉是在说求值的过程，还是先求局部，后求整体）*

__语法制导定义__（syntax-directed definition）
1. 把每个文法符号和一个属性集合相关联
2. 把每个产生式和一组 __语义规则__（semantic rule）相关联，这些规则用于计算与该产生式中符号相关联的属性值

属性可以按照如下方式求值
- 对于给定的输入串x，构建x的一个语法分析树
- 按照下面的方法应用语义规则来计算语法分析树中各个结点的属性
  - 假设语法分析树的一个结点N的标号为文法符号X
  - 用X.a表示该结点上X的属性a的值
  - 如果一棵语法分析树的各个结点上标记了相应的属性值，那么这棵语法分析树就称为 __注解__（annotated）语法分析树（简称注解分析树）\
    *（原文把annotated翻译成“注释”（comment），感觉非常不利于理解）*

图中显示一棵注解分析树
- 9-5+2的一棵注解分析树
  ```
  expr.t = 95-2+
  ├─ expr.t = 95-
  │  ├─ expr.t = 9
  │  │  └─ term.t = 9
  │  │     └─ 9 ....... (9)
  │  ├─ - ............. (-)
  │  └─ term.t = 5
  │     └─ 5 .......... (5)
  ├─ + ................ (+)
  └─ term.t = 2
     └─ 2 ............. (2)
  （转绘过程中，原本的从左往右的叶子结点，现在变成从上往下）
  ```
- 属性t与非终结符号 `expr` 和 `term` 关联
- 该属性在根结点处的值为 `95-2+`，也就是 `9 - 5 + 2` 的后缀表示
- 我们很快会看到这些表达式的计算方法

*（所谓属性，看起来就是“求值结果”，或者是希望从语法分析树中得到的结果，例子中是从语法分析树中得到后缀表达式；这种方式表示的语法分析树的特点是容易验证，但似乎暂时并没有说明如何获得该树；除此以外，仍然表明了根节点的计算要依据子节点的计算结果）*

__综合属性__（synthesized attribute）
- 如果某个属性在语法分析树结点N上的值是由N的子节点以及N本身的属性值确定的\
  ~~*（你在开玩笑吗？“属性在结点N上的值”，一部分决定于“N本身的属性值”？自己决定自己？）*~~\
  *（可能翻译有问题，这里应该是指，结点N本身带有如何把子节点的结果“综合”起来的规则描述）*
- 那么这个属性就称为 __综合属性__

综合属性具有一个很好的性质：只需要对语法分析树进行一次自底向上的遍历，就可以计算出属性的值

预告：
- 在5.1.1节中，我们将讨论另外一种重要的属性：“继承”属性
- 通俗地讲，继承属性在某个语法分析树结点上的值是由语法分析树中该结点本身、父节点以及兄弟结点上的属性值决定的

*（明白了，这是在说明，并不是所有所谓“属性”都能够通过自底向上遍历树的方式，方便地计算。也就是说，只有“综合属性”才能这样做。所谓“综合”的含义应该是指，“取自后代，将结果进行综合”）*

例子：前面所说图中注解分析树是根据 __语法制导定义__ 得到的
- 定义
  |产生式|语义规则|
  |-|-|
  |`expr->expr1+term`|`expr.t=expr1.t\|\|term.t\|\|'+'`|
  |`expr->expr1-term`|`expr.t=expr1.t\|\|term.t\|\|'-'`|
  |`expr->term`|`expr.t=term.t`|
  |`term->0`|`term.t='0'`|
  |`term->1`|`term.t='1'`|
  |...|...|
  |`term->9`|`term.t='9'`|
- 该定义用于把一个表达式翻译为该表达式的后缀形式
- 待翻译的表达式是一个由加号和减号分隔的数位序列
- 图中每个非终结符号有一个值为字符串的属性t，表示由该非终结符号生成的表达式的后缀表示形式
- 语义规则中的符号 `||` 表示字符串的连接运算符\
  *（明白了，所谓语法制导定义，应该是属于语义分析这一块，其输入为语法树，输出为另一语法树）*
- 规则解释：*略*

<div style="border:1px,solid;padding:10px">

**区分一个非终结符号的不同使用的规则**
- 在规则中，经常要区分一个非终结符号在产生式的头和/或体中的使用
- 原因是，语法分析树中，标号为同一非终结符号的不同结点通常在翻译中具有不同的属性值

我们将采用规则
- 出现在式头的非终结符号没有下标
- 在产生式体的非终结符号带有不同的下标
- 同一个非终结符号的所有出现都按照这种方式区分
- 下标不是名字的组成部分

</div>

## 简单语法制导定义
__简单__（simple）语法制导定义：
- 上面的例子中，要得到代表产生式头部的非终结符号翻译结果的字符串
- 只需要将产生式体中各非终结符号的翻译结果按照它们在非终结符号中的出现顺序连接起来
- 并在其中穿插一些附加串即可
- 具有这个性质的语法制导定义，称为简单语法制导定义

例子：*略*

当讨论翻译方案的时候，我们将看到，一个简单语法制导定义的实现很简单，只需要按照它们在定义中出现的顺序打印出附加的串即可

## 树的遍历

## 翻译方案

# 语法分析
<i style="color:gray">对应扫描中文版pdf页码32</i>


[代目录](ReadMe.md#代目录)