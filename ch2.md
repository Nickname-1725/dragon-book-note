[代目录](ReadMe.md#代目录)

本章内容
- 对本书[第3章]至[第6章]中介绍编译技术的总体介绍
- 通过开发一个可运行Java程序演示这些编译技术
- 可以将具有代表性的程序设计语言翻译为三地址代码
- 重点是编译器的前端，特别是词法分析/语法分析/中间代码生成
- [第7章]和[第8章]将介绍如何根据三地址代码生成机器指令
- 从小事做起，建立一个将中级算数表达式转换为后缀表达式的语法制导翻译器
- 扩展这个翻译器，使它能够将某些程序片段转换为三地址代码

# 引言
<i style="color:gray">对应扫描中文版pdf页码24</i>

__语法__
- 分析阶段的工作是围绕“语法”展开的
- 一个程序式设计语言的 __语法__ （syntax）描述了该语言程序的正确形式
- __语义__（semantics）定义了程序的含义

__上下文无关文法__ 或 __BNF__（backus-naur范式）
- 描述语法的一个广泛使用的表示方法
- 不仅可以描述一个语言的语法，还可以指导程序翻译的过程\
  *（在EOPL（编程语言要领）里面也是这样的）*
- 在2.3节中，我们将介绍一种面向文法的翻译技术，__语法制导翻译__（syntax-directed translation）\
  *（应该是翻译的问题，应该翻译成语法导向翻译）*
- 语法扫描，或者语法分析，将在2.4节中介绍

使用现有语义表示方法来描述一个语言的语义难度远远大于描述语言语法的难度

本章其余部分快速浏览编译器前端模型
- 首先介绍语法分析器
- 首先考虑从中缀表达式到后缀表达式的语法制导翻译过程
- 将表达式翻译为后缀形式的过程可以充分演示语法分析技术，同时这个翻译过程又很简单
- 我们将在第2.5节中给出翻译器的全部程序

__标识符__
- 语法分析器使得翻译器可以处理由多个字符组成的构造，比如标识符
- 标识符由多个字符组成，但是在语法分析阶段被当作一个单元，这样的单元称作 __词法单元__（token）

中间代码生成
- 抽象语法树：表示了源程序的层次化语法结构；
- 语法分析器生成一棵语法树，它又被进一步翻译为三地址代码
- 有些编译器会将语法分析和中间代码生成合并为一个组件

# 语法定义
<i style="color:gray">对应扫描中文版pdf页码25</i>

- 这一节将介绍描述程序设计语法的表示方法：__上下文无关文法__
- 本书中，文法将被用于组织编译器前端

文法
- 自然地描述了大多数程序设计构造的层次化语法结构
- `if (expression) statement else statement`
  - 用 `expr` 表示表达式，用变量 `stmt` 表示语句
  - `stmt -> if (expr) stmt else stmt`
  - 其中的箭头可以读作“可以具有如下形式”
- 这样的规则称为 __产生式__（production）
- 一个产生式中，关键字 `if` 和括号这样的词法元素称为 __终结符号__（terminal）
- 像 `expr` 和 `stmt` 这样的变量，称为 __非终结符号__（nonterminal）\
  *（尚可继续代换的即“非终结”，无法再代换的即“终结”）*

## 文法定义
__上下文无关文法__ 的组成四元素
1. 终结符号集合，有时也称“词法单元”，是该文法所定义的语言的基本符号的集合
2. 非终结符号集合，有时也称“语法变量”。每个非终结符号表示一个终结符号的集合
3. 一个产生式集合
    - 包括
      - 一个 __产生式头部__ 或 者 __左部__ 的非终结符号
      - 一个箭头
      - 一个 __产生式体__ 或 __右部__ 的由终结符号及非终结符号组成的序列
    - 产生式主要用来表示某个构造的某种书写方式\
      *（既然是书写方式，是不是说要遵循源语言书写的习惯？）*
4. 指定一个非终结符号为 __开始符号__

<div style="border:1px solid;padding:10px">

**词法单元和终结符号**

编译器中，词法分析器
- 读入源程序的字符序列
- 组织为具有词法含义的词素
- 输出代表词素的词法单元序列

词法单元组成
1. 名字：
    - 语法分析器进行语法分析使用的抽象符号
    - 常常称为 __终结符号__
2. 属性值：
    - 如果词法单元具有属性值，囊二这个值就是指向符号表的指针
    - 符号表包含了该词法单元的附加信息，通常不是文法的组成部分
    - 我们在讨论语法分析时，通常将词法单元和终结符号当作同义词

</div>

描述文法时
- 我们会列出文法的产生式
- 首先列出开始符号对应的产生式
- 为表示方便，以同一个终结符号为头部的多个产生式的体可以放在一起表示，不同体之间用符号 `|`（读作“或”）分隔

描述文法的习惯（续）
- 如果某个非终结符号是某个产生式的头部，我们说该产生式是该非终结符号的产生式
- 零个终结符号组成的串称为 __空串__（empty string），记为 $\epsilon$

## 推导
根据文法推导符号时
- 从开始符号出发，不断将某个非终结符号替换为该非终结符号的某个产生式的体
- 可以从开始符号推导得到所有终结符号串的集合，称为该文法定义的 __语言__

*（从一般到特殊，从文法的规则，推导出具体的一串符号序列；所有凡是可能的序列，统称为语言）*

__语法分析__ 的任务
- 接受一个终结符号串作为输入，找出从文法开始符号推导出这个串的方法
- 如果不能从文法的开始符号推导得到该终结符号串，则报告该终结符号串中包含的语法错误

*（有点逆向求解问题的感觉）*

预告
- 主要语法分析方法将在第4章中讨论
- 本章中，为简单起见，首先处理像 `9 - 5 + 2` 这样的源程序，其中每个字符均为一个终结符号\
  *（其实，语法分析这个步骤，它真正的输入应该是“符号流”，也就是词法分析的输出，而不是真正的字符串；前面文法里面的“终结/非终结符号”，应该都属于“符号流”）*
- 一般情况下，一个源程序会包含由多个字符组成的词素，这些词素由词法分析器组成词法单元，而词法单元的第一个分量就是被语法分析器处理的终结符号

## 语法分析树
语法分析树
- 用图形的方式展现了从文法的开始符号推导出响应语言中符号串的过程

正式地讲，给定一个上下文无关文法，该文法的一颗语法分析树具有以下性质
1. 根节点的符号为文法的开始符号
2. 每个叶子结点的标号为一个终结符号或 $\epsilon$
3. 每个内部结点的标号为一个非终结符号
4. 如果非终结符号A是某个内部结点的标号，并且它的子结点标号从左到右分别为 $X_1,X_2,\cdots,X_n$
    - 那么必然存在产生式 $A\rightarrow X_1X_2\cdots,X_n$ 其中 $X_1,X_2,\cdots,X_n$ 既可以是终结符号，又可以是非终结符号
    - 作为一种特殊情况，如果 $A\rightarrow\epsilon$ 是一个产生式，那么一个标号为A的结点可以只有一个标号为 $\epsilon$ 的子结点

<div style="border:1px solid;padding:10px">

**关于树形结构的术语**
- 一棵树由 __结点__（node） 组成
  - 结点可以带有标号（label）
  - 本书中标号通常是文法符号
  - 当我们画一棵树时，常常只用这些标号代表相应的结点
- 树有且仅有一个根（root）结点……

*略*

</div>

一颗语法分析树的叶子结点从左向右构成了树的 __结果__（yield）
- 也就是从这棵语法分析树的根结点上的非终结符号推导得到的符号串
- 任何树的叶子结点都有一个自然的从左到右的顺序

__语法分析__
- 一个文法的语言的另一个定义：任何能够从某棵语法分析树生成的符号串的集合
- 为一个给定的终结符号串构建一棵语法分析树的过程称为对符号串进行 __语法分析__

## 二义性
二义性
- 一个文法可能有多棵语法分析树能够生成同一个给定的终结符号串
- 这样的文法称为具有 __二义性__（ambiguous）
- 要证明一个文法具有二义性，我们只需要找到一个终结符号串，说明它是两棵以上语法分析树的结果
- 对策
  - 需要为编译应用设计出没有二义性的文法
  - 或者在使用二义性文法时使用附加的规则消除二义性

## 运算符的结合性



## 运算符的优先级

## 2.2节的练习

# 语法制导翻译
<i style="color:gray">对应扫描中文版pdf页码32</i>



[代目录](ReadMe.md#代目录)