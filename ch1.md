[代目录](ReadMe.md#代目录)

<i style="color:gray">对应扫描中文版pdf页码1</i>

编译器：从程序设计语言翻译成计算机能执行的形式

本书介绍
- 设计和实现编译器的方法
- 用于构建面向多种语言和机器的翻译器的一些基本思想

研究编译器编写涉及到
- 程序设计语言
- 计算机体系结构
- 形式语言理论
- 算法和软件工程

本章介绍
- 语言翻译器的不同形式
- 概述一个典型编译器的结构
- 程序设计和硬件体系结构的发展趋势
- 我们研究编译器时需要用到的重要程序涉及语言概念

# 语言处理器
<i style="color:gray">对应扫描中文版pdf页码1</i>

- 编译器：
  - 一个程序
  - 阅读某一种语言（源语言）编写的程序
  - 翻译成一个等价的、用另一种语言（目标语言）编写的程序
  - 重要任务：报告在翻译过程中发现源程序中的错误
- 解释器
  - 另一种常见的语言处理器
  - 不通过翻译的方式生成目标程序
  - 直接利用用户提供的输入执行指定操作

区别
- 由编译器产生的机器语言目标程序通常比一个解释器快很多
- 解释器的错误诊断效果通常比编译器更好，因为逐个语句执行源程序

Java 语言：结合了编译和解释过程，一个混合编译器

预处理器
- 一个源程序可能被分割为多个模块，存放于独立的文件中
- 把源程序聚合在一起的任务有时由 *预处理器* 独立完成
- 预处理器还负责把宏转换为源语言语句

一个语言处理系统
- 源程序->_预处理器_->
- 经过预处理的程序->_编译器_->
- 目标汇编程序->_汇编器_->
- 可重定位机器代码->_链接器/加载器_->\
  库文件/可重定位对象文件->_链接器/加载器_
- 目标机器代码

# 一个编译器的结构
<i style="color:gray">对应扫描中文版pdf页码2</i>

编译器的映射过程有两部分
1. 分析部分
   - 把源程序分解为多个组成要素
   - 在要素之上加上语法结构
   - 使用这个结构创建源程序的一个 __中间表示__
   - 如果分析部分检查出源程序没有按照正确的语法构成/语义上不一致，就必须提供有用信息
   - 收集有关源程序的信息，存放在 __符号表__ 的数据结构中
2. 综合部分
   - 根据 __中间表示__ 和 __符号表__ 中的信息构造用户期待目标程序

分析部分经常被称为编译器的 __前端__，综合部分被称为 __后端__

编译过程可以分为一组步骤

一个典型的把编译程序分解为步骤的方式
1. 字符流-> __词法分析器__ ->
2. 符号流-> __语法分析__ ->
3. 语法树-> __语义分析__ ->
3. 语法树-> __中间代码生成器__ ->
4. 中间表示形式-> __机器无关代码优化器__ ->
5. 中间表示形式-> __代码生成器__ ->
6. 目标机器语言-> __机器相关代码优化器__ ->
7. 目标机器语言

说明
- 实践中，多个步骤可能组合在一起，组合在一起的步骤之间的中间表示不需要明确构造出来
- 存放整个源程序信息的符号表可由编译器各个步骤使用
- 优化的步骤是可选的，两个优化步骤之一可以省略

## 词法分析
编译器的第1个步骤： __词法分析__ 或者 __扫描__

词法分析器
- 读取组成源程序的字符流
- 组织为有意义的 __词素__ （lexeme）序列
- 对于每个词素，词法分析器产生 __词法单元__ （token）作为输出\
  `<token-name, attribute-value>`
- 词法单元被传递给下一个步骤，语法分析
- 词法单元的分量
  - `token-name`：语法分析步骤使用的抽象符号
  - `attribute-value`：指向符号表中关于这个词法单元的条目\
  <i style="color:gray">似乎类似于EOPL（编程语言要领）里面的指向变量对应值的地址</i>

举例：假设赋值语句 `position = initial + rate * 60`
1. `position` 是词素，映射成词法单元 `<id, 1>`，__id__ 是标识符（identifier），1指向符号表中position对应的条目，条目中存放标识符有关信息，例如名字、类型
2. 赋值符号 `=` 是词素，映射成词法单元 `<=>`。它不需要属性，忽略第二个分量；也可使用 __assign__ 这样的抽象符号作为词法单元名字
3. `initial` 是个词素，映射成词法单元 `<id, 2>`，2指向 `initial` 对应的符号表条目
4. `+` 是一个词素，被映射成词法单元 `<+>`
5. `rate` 是一个词素，被映射成 `<id, 3>`
6. `*` 是一个词素，`<*>`
7. `60` 是一个词素， `<60>`

分隔词素的空格会被词法分析器忽略

翻译过程
1. `position = initial + rate * 60` -> __词法分析器__ ->
2. `<id,1> <=> <id,2> <+> <id,3> <*> <60>` -> __语法分析器__ ->
3. `树形` -> __语义分析器__ ->
4. `带inttofloat的树形` -> __中间代码生成器__ ->
5. `命令式编程代码块` -> __代码优化器__
6. `合并的命令式编程代码块` -> __代码生成器__ ->
7. `汇编语言`

## 语法分析
编译器的第2个步骤称为 __语法分析__（syntax analysis）或者 __解析__（parsing）。

语法分析器
- 使用词法分析器生成的各个词法单元的第一个分量，创建树形中间表示
- 该中间表示给出了词法分析产生的词法单元流的结构
- 一种常用的表示方法： __语法树__（syntax tree）
  - 树每个内部结点代表一个运算
  - 子节点表示该运算的分量

*（关于介绍 `position = initial + rate * 60` 的抽象语法树）*

编译器的后续步骤使用这个语法结构帮助分析源程序，生成目标程序

预告
- 在第4章，我们将
  - 使用上下文无关文法描述程序涉及语言的语法结构
  - 讨论为某些类型的语法自动构造高效语法分析器的算法
- 在第2章和第5章，将看到语法制导的定义将有助于描述对程序设计语言结构的翻译

## 语义分析
__语义分析器__（semantic analyzer）
- 使用语法树和符号表中的信息检查源程序是否和程序定义的语义一致
- 收集类型信息，存放在语法树或符号表中，以便在随后的中间代码生成中使用

__类型检查__（type checking）
- 语义分析的一个重要部分
- 编译器检查每个运算符是否具有匹配的运算分量

__自动类型转换__（coercion）：程序设计语言可能允许某些类型转换

预告：类型检查和语义分析将在[第6章](ch6.md)中讨论。

## 中间代码生成
中间代码生成：
- 源程序的语法分析和语义分析完成之后
- 很多编译器生成一个明确的/低级的/类机器语言的中间表示
- 可以看作是某个抽象机器的程序
- 应该具有两个重要性质
  1. 易于生成
  2. 能够被轻松地翻译为目标机器上的语言

预告：[第6章](ch6.md)中
- 我们将考虑一种称为 __三地址代码__（three-address code）的中间表示形式
- 表示由一组类似于汇编语言的指令组成
- 每个指令具有三个运算分量，每个运算分量都像一个寄存器
- 三地址指令指的指出的几点
  1. 每个三地址赋值指令的右部最多只有1个运算符，这些指令确定了运算完成的顺序
  2. 编译器应该生成一个临时名字存放三地址指令计算得到的值
  3. 有些三地址指令的运算分量少于3个

预告：
- 在[第6章](ch6.md)中我们将讨论在不同编译器中用到的主要中间表示形式
- [第5章](ch5.md)将介绍语法制导翻译技术
  - 这些技术将在[第6章](ch6.md)被用于处理典型程序设计语言构造，进行类型检查和中间代码生成
  - 这些程序设计语言构造包括：表达式、控制流构造、过程调用

*（表达式、控制流、过程调用似乎在EOPL（编程语言要领）里面已经见过了，可能不会很困难）*

## 代码优化
机器无关代码优化步骤试图改进中间代码，以便生成更好的目标代码
- 通常意味着更快
- 也可能有其它目标，如更短、能耗更低

不同编译器所做的代码优化工作量相差很大
- 优化工作做得最多的编译器，在优化阶段会花相当多的实践
- 简单的优化方法可以极大地提高目标程序的运行效率，而不会过多降低编译速度

预告：从[第8章](ch8.md)开始，将详细讨论机器无关/机器相关代码优化

## 代码生成
代码生成器以源程序的中间表示形式作为输入，映射到目标语言

预告：我们将在[第7章](ch7.md)中看到
- 时刻运行的存储组织方法依赖于被编译的语言
- 编译器在中间代码生成/代码生成阶段做出有关存储分配的决定

## 符号表管理
符号表管理
- 记录源程序中使用的变量名字
- 收集和每个名字的各种属性有关的信息
- 这些属性可以提供一个名字的存储分配/类型/作用域灯信息\
  *（看着类似于EOPL（编程语言要领）里面的env模型、store模型等等）*
- 对于过程的名字，这些信息还包括
  - 参数数量和类型
  - 每个参数的传递方法（传值/传引用）及返回类型
- 为每个变量名字创建了一个记录条目，记录的字段就是名字的各个树形
- 这个数据结构应该允许编译器迅速查找到每个名字的记录，向记录中快速存放和获取记录中的数据

预告：符号表在[第2章](ch2.md)讨论

## 将多个步骤组合成趟
__一趟__
- 特定的实现中，多个步骤的活动可以组合成 __一趟__（pass）
- 每趟输入一个文件并产生一个输出文件

有些编译器集合是围绕一组精心设计的中间表示形式而创建的
- 使得我们可以把特定语言的前端和特定目标机的后端相结合
- 使用这些集合，我们可以把不同的前端和某个目标机的后端结合起来，为不同的源语言建立该目标机上的编译器
- 类似地，可以把一个前端和不同目标机后端结合，建立针对不同目标机的编译器

## 编译器构造工具
- 人们创建了一些专用的工具实现编译器的不同阶段
- 通常使用专用的语言描述和实现特定的组件
- 其中的很多工具使用了相当复杂的算法
- 最成功的工具都能够隐藏生成算法的细节，它们生成的组件易于和编译器的其它部分相集成

常见的编译器构造工具
1. 语法分析器的生成器：根据程序设计语言的语法自动生成语法分析器
2. 扫描器的生成器：根据语法单元的正则表达式生成词法分析器\
   *（正则表达式在扫描器中到底行不行呢）*
3. 语法制导的翻译引擎：生成一组用于遍历分析树并生成中间代码的例程
4. 代码生成器的生成器：依据一组关于 <u>如何把中间语言的每个运算翻译成目标机上的机器语言</u> 的规划，生成一个代码生成器
5. 数据流分析引擎：帮助收集数据流信息，即，程序中的值如何从程序的一个部分传递到另一部分。数据流分析是代码优化的一个重要部分
  *（数据流？对应哪个步骤？）*
6. 编译器构造工具集：提供用于构造编译器不同阶段的例程的完美集合

# 程序设计语言的发展历程
<i style="color:gray">对应扫描中文版pdf页码7</i>

## 走向高级程序设计语言
*略*

## 对编译器的影响
*略*

## 1.3节的练习
*略*

# 构建一个编译器的相关科学
<i style="color:gray">对应扫描中文版pdf页码8</i>

如何使用抽象方法解决问题
- 接受一个问题
- 写出抓住了问题的关键特征的数学抽象表示
- 用数学技术解决它

编译器的特点
- 必须接受所有遵循语言规范的源程序
- 源程序的集合是无穷的，程序可能大到包含几百万行代码
- 翻译一个源程序过程中，编译器所作任何翻译工作都不能改变被编译源程序的含义
- 编译器设计者工作不仅影响到他们创建的编译器，还会影响到他们所创建的编译器所编译的全部程序
- 这种杠杆作用使编译器设计回报丰厚，但开发工作具有挑战性

## 编译器设计和实现中的建模
对编译器的研究主要关于两个问题的研究
- 如何设计正确的数学模型
- 如何选择正确算法

还需要考虑到
- 对通用性/功能的要求
- 与简单性/有效性之间的平衡

最基本的数学模型
- 将在[第3章](ch3.md)介绍的有穷状态自动机、正则表达式，可以用于
  - 描述程序的词法单位（关键字、标识符等）
  - 描述被编译器用来识别这些单位的算法
- 还包括上下文无关文法，描述程序设计的语法结构，比如嵌套的括号和控制结构。我们将在[第4章](ch4.md)研究文法
- 树形结构是表示程序结构，程序到目标代码的翻译方法的重要模型。我们将在[第5章](ch5.md)介绍这一概念

## 代码优化的科学
__优化__ 的第一个目标
- 编译器为了生成比浅显直观的代码更加高效的代码而做的工作
- 这个词并不恰当，因为没有办法保证一个编译器生成的代码比完成相同任务的任何其它代码更快，或者至少一样快

现在，编译器代码优化更加重要、更加复杂：*略*

理论与技能
- 即使有可能通过随意的方法建造一个见状的编译器，实现起来也非常困难
  - 人们已经围绕代码优化建立了一套广泛有用的理论
  - 应用严格的数学基础，使得我们可以证明一个优化是正确的，并且对所有可能的输入都产生预期效果
    *（这是不是崇尚类型和形式化那批人的主张？）*
  - 从[第9章]开始，我们将会看到，如果想使得编译器产生经过良好优化的代码，图、矩阵、线性规划的模型是必不可少的
- 只有理论是不够的
  - 编译器优化中提出的很多问题都是不可判定的
  - 最重要的技能之一是明确描述出真正要解决问题的能力
  - 需要一开始就对程序的行为有中分了解，通过充分的试验和评估验证直觉

编译器优化必须满足的设计目标
- 优化必须是正确的，不能改变被编译程序的含义
- 优化必须能改善很多程序的性能
- 优化所需的实践必须保持在合理范围内
- 所需要的工程方面的工作必须是可管理的

__优化__ 的第二个目标
- 编译器应该有效提高很多输入程序的性能
- 通常意味着程序执行速度，也希望能够尽量降低生成代码的大小
- 对于移动设备，尽量降低代码的能耗也是期待的
- 通常情况下，提高执行效率的优化也能够节约能耗
- 错误报告和调试等的可用性方面也很重要

__优化__ 的第三个目标
- 需要使编译时间保持在较短范围内，支持快速的开发和调试周期
- 开始时，一个程序经常在没有进行优化的情况下开发和调试。不仅可以降低编译实践，更重要的是未经优化的代码更容易调试
- 编译器开启优化有时会暴露源程序中新的问题，因此需要对经过优化的代码再次进行测试
- 可能需要额外的测试工作，有时阻止人们在应用中使用优化技术

编译器是一个复杂的系统，必须使系统保持简单，保证设计和维护费用是可管理的

# 编译技术的应用
<i style="color:gray">对应扫描中文版pdf页码10</i>

编译器技术还有其它重要用途。编译器设计影响了计算机科学的其他领域

## 高级程序设计语言的实现
*略*

## 针对计算机体系结构的优化
*略*

## 新计算机体系的设计
*略*

## 程序翻译
*略*

## 软件生产率工具
*略*

# 程序设计语言基础
<i style="color:gray">对应扫描中文版pdf页码15</i>

讨论程序设计语言研究中最重要的术语和它们的区别。

## 静态和动态的区别

## 环境与状态

## 静态作用域和块结构

## 显式访问控制

## 动态作用域

## 参数传递机制

## 别名

## 1.6节的练习

# 第1章总结
<i style="color:gray">对应扫描中文版pdf页码7</i>

*略*

[代目录](ReadMe.md#代目录)